\chapter{Configuration}

\section{UART}
Interruptions disponibles pour le niveau de réception FIFO atteint, niveau de transmission FIFO atteint, FIFO 
dépassement ou sous-débit, ralenti de l’émetteur, changement de détection de coupure du récepteur, cadrage 
erreur, erreur de parité, détection Delta CTS, et le bruit d’échantillon de récepteur détecté (parmi 
autres). 



\section{Choix de la fréquence d'horloge}

Il faut sélectionner le bloc fonctionnel dans le  \bold{functionnal block}
\img{\rootImages/select.png}{Choix de la fréquence d'horloge}{0.5}

\section{Localisation des horloges}

Aller dans \bold{ConfigTools > Clocks}

puis vérifier que vous êtes dans l'onglet \bold{Clock\_diagramm}


\img{\rootImages/clock_diagramm.png}{Onglet du diagramme d'horloge}{0.5}

Il faut chercher sur le diagramme le nom de l'horloge correspondante et faire un click-gauche dessus: 


\img{\rootImages/select_clock.png}{Selection de la clock}{0.7}


Dans le menu latéral droit, il faut cliquer sur None et sélectionner l'horloge 

\img{\rootImages/none.png}{Selection de l'horloge à rattacher}{0.7}


Il ne reste plus qu'à mettre à jour le code avec le bouton \bold{Update}


\img{\rootImages/upadte.png}{Mise à jour du code}{0.7}



\section{UART}

\img{\rootImages/fonctionnement\_uart.png}{Principe UART}{0.8}

\section{Code ANSI}
\img{\rootImages/code\_ANSI.png}{commande code ANSI}{0.3}



\begin{Cpp}{utilisation du code ANSI} 
void clear(USART_Type *base)
{
	unsigned char buf[]="\x1B[2J\x1B[17;1H";
	USART_WriteBlocking(base, buf, sizeof(buf) - 1);
}
\end{Cpp}

\section{IRQ Number}

\begin{Cpp}{utilisation du code ANSI} 
EnableIRQ(FLEXCOMM0_IRQn);
\end{Cpp}

Pour trouver le "tableau" des IRQ Number, il faut aller dans le fichier LPC55S69\_cm33\_core0.


\section{Mode interruption}

\subsection{Question 1}

\subsection{Question 2}


\subsection{Question 3}



la variable \bold{demoRingBuffer} est un tableau qui stocke les caractères reçus par interruption.
Lorsque le tableau est plein, les caractères suivants sont stockés au début du tableau.

La variable \bold{txIndex} permet de parcourir le tableau demoRingBuffer. 

\begin{Cpp}{Code FLEXCOMM0\_IRQHandler}

void FLEXCOMM0_IRQHandler(void) {
    uint8_t data;

    /* If new data arrived. */
    if ((kUSART_RxFifoNotEmptyFlag | kUSART_RxError) & USART_GetStatusFlags(USART0)) {
        data = USART_ReadByte(USART0);
        /* If ring buffer is not full, add data to ring buffer. */
        if (((rxIndex + 1) \% DEMO_RING_BUFFER_SIZE) != txIndex) {
            demoRingBuffer[rxIndex] = data;
            rxIndex++;
            rxIndex \%= DEMO_RING_BUFFER_SIZE;
        }
    }

}
\end{Cpp}



\subsection{Question 4}

demoRingBuffer[rxIndex] 

La variable txIndex représente l'index de la donnée à envoyer et rxIndex représente l'adresse de stockage de la donnée reçue.

Le mot clé volatile signifie que la variable est accessible depuis n'importe où (variable globale).


Identifier sur cet exemple le moyen qui a été utilisé pour synchroniser l'envoi de la donnée avec le code principal ?

On utilise une interruption pour sortir d'une boucle et continuer le code.

\begin{Cpp}{Code FLEXCOMM0\_IRQHandler}
USART_TransferCreateHandle(USART1, &g_usartHandle, USART_UserCallback, NULL);

...

while (!txFinished)
{
}
\end{Cpp}

\begin{Cpp}{Code FLEXCOMM0\_IRQHandler}
void USART_UserCallback(usart_handle_t *handle, status_t status, void *userData)
{
    userData = userData;
    if (kStatus_USART_TxIdle == status)
    {
        txFinished = true;
    }
    if (kStatus_USART_RxIdle == status)
    {
        rxFinished = true;
    }
}
\end{Cpp}