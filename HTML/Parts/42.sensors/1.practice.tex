\chapter{Mise en pratique}

Les codes suivants seront utilisés avec le serveur Web mis en place avec l'ESP12.\\
Cela permettra de réaliser une interface plus élaborée avec des capteurs et actionneurs.

\section{Utilisation du DHT11}


\subsection{Objectif}
L'intégration du code permettant de lire la température permettra d'obtenir l'interface suivante, à savoir un graphique pour 
visualiser la température et l'humidité en temps réel.

\img{\rootImages/graphe.png}{Le rendu de l'interface}{0.3}

\subsection{Branchements}

\img{\rootImages/dht_esp12.png}{Le branchement du module DHT}{0.5}

\subsection{Programme de test}

Avant de tester le code complet du DHT11/22 avec le serveur Web , on va essayer le module DHT sans le serveur. 
Pour cela, on va téléverser le programme suivant\footnote{Fichier \lbl{red}{FILE}{temperature\_humidite.ino}} :

\begin{Cpp}{Programme DHT11/22 minimaliste}
    #include "DHT.h"
    #define DHTPIN D2     //Broche du capteur
    
    #define DHTTYPE DHT11   // DHT 11
    //#define DHTTYPE DHT22   // DHT 22 
    //#define DHTTYPE DHT21   // DHT 21 
    
    DHT dht(DHTPIN, DHTTYPE);
    
    void setup() {
      
      Serial.begin(115200);
      dht.begin();          //Initialisation du capteur
    }
    
    void loop() {
    
      float h = dht.readHumidity();       //Récupère la température
      float t = dht.readTemperature();    //récupère l'humidité
    
      Serial.print("Humidite: ");
      Serial.print(h);
      Serial.print("\%  Temperature: ");
      Serial.print(t);
      Serial.println("C ");
      
      delay(2000);
    
    }
\end{Cpp}

Si vous obtenez le résultat suivant en lançant la console série, c'est que le capteur est fonctionnel.

\img{\rootImages/term_dht.png}{Le capteur DHT fonctionnel}{0.5}

Il ne vous reste plus qu'à lancer le programme \lbl{red}{FILE}{Serveur\_Web\_DHT11\_Graphe.ino}.

\subsection{Explications}

Pour gérer les températures et les valeurs d'humidité dans le temps, un tableau 'circulaire' est utilisé dans le programme. \\
Il consiste à remplir au fur et à mesure un tableau et quand celui-ci est plein, on décale les valeurs pour ajouter la dernière.

Prenons un exemple avec un tableau de 5 éléments auquel on cherche à ajouter le cycle suivant : 21,22,21,22,23,24,25,26 \\

\begin{numeric}{Les tableaux 'circulaires'}
    Etape Initial & 2D{0} 2D{0} 2D{0} 2D{0} 2D{0} \\
    Ajout de '21' & 2D{21} 2D{0} 2D{0} 2D{0} 2D{0} \\
    Ajout de '22' & 2D{21} 2D{22} 2D{0} 2D{0} 2D{0} \\
    Ajout de '21' & 2D{21} 2D{22} 2D{21} 2D{0} 2D{0} \\
    Ajout de '22' & 2D{21} 2D{22} 2D{21} 2D{22} 2D{0} \\
    Ajout de '23' & 2D{21} 2D{22} 2D{21} 2D{22} 2D{23} \\
    Ajout de '24' & 2D{22} 2D{21} 2D{22} 2D{23} 2D{24} \\
    Ajout de '25' & 2D{21} 2D{22} 2D{23} 2D{24} 2D{25} \\
    Ajout de '26' & 2D{22} 2D{23} 2D{24} 2D{25} 2D{26} \\
\end{numeric}%

Ce mouvement cyclique est géré par la fonction \lbl{blue}{FUNC}{updateRings} dans le fichier \lbl{purple}{LIB}{circularRings.h}

La fonction principale pour gérer le graphique est la fonction \lbl{blue}{FUNC}{getString} : 

\begin{Cpp}{Lecture de la température et de l'humidité}

    temperature = dht.readTemperature();
    humidity  = dht.readHumidity();

\end{Cpp}

Une fois ces deux données lues, on actualise les tableaux circulaires contenant les températures, les valeurs d'humidité et les références du graphique \footnote{Tableau contenant que des '0'}.

\begin{Cpp}{Actualisation des tableaux}

    updateRings(&current_index, NB_DATA_TEMP, temperature, humidity); //Mise à jour des tableaux

\end{Cpp}

On créer ensuite les chaines de caractères pour générer le graphique :

\begin{Cpp}{Génération du graphique}

    String dataTemperatures = concatenateArray(temperatures, current_index);
    String dataHumidities = concatenateArray(humidities, current_index);
    String dataReferences = concatenateArray(references, current_index); //Tableau contenant toutes les valeurs à 0, pour afficher la référence sur le graphique
    
    String dataTime ="[";
    for (int i=current_index;i>0;i--) {
      dataTime += "'"+String(i)+"',";
    }
    dataTime += "]";

\end{Cpp}

Une fois toutes les données, on génère la page dans son intégralité :


\begin{Cpp}{Génération de la page}

const String fullPageContent = "<html>\
<head>\
  <title>Serveur Web CREPP</title>\
  <meta charset=\"utf-8\"/> \
  <meta http-equiv=\"refresh\" content=\""+String(REFRESH_PAGE_DELAY)+"\">\
  <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\">\
  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js\"></script>  \
  </head>\
<body style=\"margin-left:5\%;\">\
  <h1>Interface ESP12</h1><br>\
  <h3>Contrôle de la LED sur la broche <span class=\"badge badge-secondary\">D4</span></h3><br>\
    <a href=\"/?LED=ON\"><button class=\"btn btn-success\">Allumer</button></a>\
    <a href=\"/?LED=OFF\"><button class=\"btn btn-danger\">Eteindre</button></a><br><br>\
  <h3>Mesure de la température et humidité avec le module DHT11 sur la broche <span class=\"badge badge-secondary\">D2</span></h3><br>\
    <br>\
    >>> <b>Temperature</b> : "+String(temperature)+" C<br>\
    >>> <b>Humidite</b> : "+String(humidity)+"%\
    <div style='max-width:40\%;'><canvas id=\"myChart\" width=\"600\" height=\"450\"></canvas></div> \
      <script> \
var ctx = document.getElementById('myChart'); \
var temperatures = "+dataTemperatures+";\
var references = "+dataReferences+";\
var humidities = "+dataHumidities+";\
var time = "+dataTime+";\
var myChart = new Chart(ctx, {type: 'line', data: { labels: time, datasets: [{ label: 'Temperature', data: temperatures, borderColor: 'blue',backgroundColor: '', fill: 0}, { label: 'Référence', data: references, borderColor: 'black',backgroundColor: '', fill: 1}, { label: 'Humidité', data: humidities, borderColor: 'green',backgroundColor: '', fill: 0}]}})</script>\
</body>\
</html>";

\end{Cpp}


\section{Utilisation du HC-SR04}

\subsection{Branchements}

\img{\rootImages/hcsr04_esp.png}{Branchement du capteur}{0.6}

\subsection{Code complet}

\begin{Cpp}{Code complet pour le capteur HCSR-04}

#define TRIGGER_PIN D5  //Broche Trigger
#define ECHO_PIN D6     //Broche Echo

#define SOUND_VELOCITY 0.034 //Vitesse en cm/us

float distance = 0.0;

void setup() {

  Serial.begin(9600);         //Communication à 9600 bauds
  pinMode(TRIGGER_PIN, OUTPUT); //Broche Trigger en sortie
  pinMode(ECHO_PIN, INPUT);     //Broche Echo en entrée

  digitalWrite(TRIGGER_PIN, LOW);

}//End setup

void loop() {

  digitalWrite(TRIGGER_PIN, HIGH); //Envoie une impulsion de 10us
  delayMicroseconds(10);
  digitalWrite(TRIGGER_PIN, LOW);
  
  int duration = pulseIn(ECHO_PIN, HIGH); //Récupère le temps à l'état Haut de la broche ECHO

  distance = duration * SOUND_VELOCITY/2; //Distance en cm, v=d/t

  Serial.print("Distance (cm) = ");
  Serial.println(distance);
  
  delay(1000);
}

\end{Cpp}


\section{Utilisation d'un capteur PIR}

\subsection{Branchements}

\img{\rootImages/pir_esp.png}{Branchement du capteur PIR}{0.5}

\subsection{Code complet}

\begin{Cpp}{Code complet}

#define LED D2    //Broche de la LED
#define OUT D7     //Broche du capteur PIR
    
int status = LOW;     //Statut du mouvement : LOW : pas de mouvement détecté
bool outValue = 0;    //Valeur du capteur
long beginTime = 0;   //instant du déclenchement lors de la ldétection d'un mouvement
    
void setup() 
{
      
  pinMode(LED, OUTPUT); //LED en sortie
  pinMode(OUT, INPUT);  //Broche du capteur en entrée
  Serial.begin(9600);   //Vitesse de communication à 9600 bauds

}//End setup
    
void loop(){
    
  outValue = digitalRead(OUT);          //Lire létat du capteur
        
  if (outValue == HIGH)                 //Détection d'un mouvement
  {
    digitalWrite(LED, HIGH);            //Allume la LED
    
    if (status == LOW) 
    {
      Serial.println(">>> Mouvement ");
      status = HIGH;                    //Mise à jour du statut du capteur
      beginTime = millis();             //Sauvegarde du temps                   
    
    }//End if
    
    } 
    else                                //Aucun mouvement
    {
          
      digitalWrite(LED, LOW);           //Eteint la LED
            
      if(status == HIGH)                //Fin de détection
      { 
        Serial.print(">>> Fin du mouvement");
        status = LOW;                               //Mise à jour du statut du capteur
        unsigned long duree = millis() - beginTime; //Calcul de la durée du mouvement
        Serial.print(">>> Duree = ");
        Serial.print(duree);
        Serial.println(" ms");
    
      }//End if
    }//End else
}//End loop
\end{Cpp}

\section{Utilisation d'un écran OLED}


\subsection{Récupération de l'adresse I2C}

Pour tous les périphériques I2C, il convient de connaître l'adresse du périphérique. Or parfois on ne s'en rappel plus.
Il existe un code qui permet de scanner toutes les adresses possibles et d'afficher l'adresse du composant qui est relié au bus I2C.

Voici le code, disponible dans les exemples de la classe Wire \footnote{Classe qui gère le protocole I2C} : 

\begin{Cpp}{Un scanner I2C}

void loop()
{
  byte error, address;
  int nDevices;
     
  Serial.println("Scanning...");
     
  nDevices = 0;
  for(address = 1; address < 127; address++ )
  {
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
     
    if (error == 0)
    {
      Serial.print("I2C device found at address 0x");
      if (address<16) {
        Serial.print("0");
      }
      Serial.print(address,HEX);
      Serial.println("  !");
      nDevices++;
    }
    else if (error==4)
    {
      Serial.print("Unknow error at address 0x");
      if (address<16) {
        Serial.print("0");
      } 
      Serial.println(address,HEX);
    }    
  }
  if (nDevices == 0) {
    Serial.println("No I2C devices found\n");
  }
  else {
    Serial.println("done\n");
  }
  delay(5000);         
    
}
\end{Cpp}


\subsection{Code complet}

\begin{Cpp}{Code complet}

  #include "SSD1306Ascii.h"
  #include "SSD1306AsciiAvrI2c.h"
   
  #define I2C_ADDRESS 0x3C
   
  SSD1306AsciiAvrI2c oled;
   
  void setup() {
  
    //Init size
    oled.begin(&Adafruit128x64, I2C_ADDRESS);
    oled.setFont(Adafruit5x7);  
    oled.clear();
    oled.set2X();
  
    
    oled.println("CREPP");
    oled.set1X();
    oled.println("Club de");
    oled.println("Robotique et");
    oled.println("d'Electronique");
    oled.println("Programmable");
   
  }
  void loop() {
   
  }
\end{Cpp}

\subsection{Branchements}

\img{\rootImages/esp_oled.png}{Branchements de l'éran OLED}{0.5}

\img{\rootImages/oled_result.jpg}{L'écran OLED fonctionnel}{0.4}



