\chapter{Introduction}

\section{Présentation}

Ce tutoriel a pour but d'accompagner la mise en place du projet de supervision en Python avec le logiciel QtDesigner et les outils de Pyqt5. Ce document explique les bases du logiciel afin de faciliter sa compréhension.

\section{Pré-requis}

Ce tutoriel a été rédigé avec la version 5.14 de QtDesigner. \newline

\chapter{Prise en main de QtDesigner}

\section{Nouveau projet}

Tout d'abord, il faut ouvrir le logiciel QtDesigner, disponible après une recherche dans la barre de menu.

\img{\rootImages/designer_context_search_software.png}{Ouverture du logiciel}{0.4}

La commande suivante permet également de lancer QtDesigner via une console : 
\begin{lstlisting}
designer
\end{lstlisting}
Au démarrage, une fenêtre apparaît. Sélectionnez \bold{'MainWindow'} puis 'Créer'

\img{\rootImages/designer_context_new_window.png}{Fenêtre au démarrage}{0.4}


Il s'agit de déterminer le type de fenêtre que nous souhaitons implémenter dans le logiciel. Dans notre cas, nous souhaitons créer une fenêtre principale. Cet objet possède de base certaines propriétés pratiques comme un menu en en-tête de fenêtre, et beaucoup d'autres choses qui pourront nous servir pour la suite.

\img{\rootImages/designer_context_qt_designer_menu.png}{Menu possible avec une fenêtre 'MainWindow'}{0.8}
\bold{
A ce moment-là, nous vous invitons à choisir un nom pour le projet, comme par exemple \dir{UI\_demo} et a le sauvegarder dans un répertoire appelé \dir{Qt\_tutoriel.}}
\bold{Ce dossier sera notre répertoire de travail tout au long du tutoriel}. \newline
Le préfixe UI permet de repérer que ce fichier est un document QtDesigner (format .ui). \bold{Dans notre cas, le fichier s'appellera \file{UI\_demo.ui}}. \newline \newline 
{\color{red}Il est fortement conseillé de sauvegarder régulièrement votre travail, sous peine de perdre vos données.}




\section{Présentation de l'interface}

Une fois que le fichier \file{UI\_demo.ui} est ouvert, vous arrivez sur une page similaire à l'image suivante : \newline

\img{\rootImages/designer_context_main_window.png}{Fenêtre principale de QtDesigner avec ses outils}{0.25}

Cette page regroupe tous les élements permettant de faire une interface graphique minimaliste.


Tout d'abord nous avons une barre d'outils. \newline

\img{\rootImages/designer_context_toolbar.PNG}{Barre d'outils supérieure}{0.6}


Cette barre permet de gérer les fichier (Enregistrer, ouvrir un nouveau fichier...) et propose quelques utilisations plus spécifiques que nous verrons plus tard. \newline

En plus de ça, nous avons donc 5 zones d'outils, sans compter la barre d'outil supérieure: 

\begin{enumerate}

    %ITEM
    \item {\color{green}Une liste de widgets}
    Dans cette section sont disponibles l'ensemble des widgets communs que vous souhaitez inclure dans votre projet.
    \img{\rootImages/designer_widget_list.png}{Zone des widgets}{0.6}

    %ITEM
    \item {\color{blue}Une zone de travail}
    Cet espace de travail représente une vue de la fenêtre de votre futur logiciel avec ses widgets. \newline
    Au démarrage d'un projet, cet espace est vide.
    \img{\rootImages/designer_workspace.png}{La zone de travail}{0.6}


    %ITEM
    \item {\color{red}Un inspecteur d'objet que nous appellerons \textbf{arborescence} dans le document}
    Tous les widgets insérés dans la zone de travail viendrons s'ajouter automatiquement dans l'arborescence.
    \img{\rootImages/designer_tree.png}{Arborescence de la fenêtre}{0.5}

    
    %ITEM
    \item {\color{magenta}Un éditeur de propriétés}
    Chaque widget possède des propriétés que nous pouvons changer à tout instant avec cet éditeur.
    \img{\rootImages/designer_properties.png}{Éditeur de propriétés}{0.5}

    %ITEM
    \item {\color{gray}Un explorateur de ressource}, qui permettra par la suite de mettre en forme les Widgets proposés par le module \lib{ENIBSupervision} utilisé dans le projet.
    
\end{enumerate}


\subsection{Placer un widget}


Prenons un bouton (QPushButton) parmi la {\color{green}liste des widgets} et déplaçons le sur {\color{blue}zone de travail} (avec la souris, clic-gauche maintenu sur le widget pendant le déplacement), au centre de l'écran.


\img{\rootImages/designer_workspace_add_widget.png}{Ajouter un widget en le glissant vers l'espace de travail}{0.4}


Vous devriez obtenir un bouton similaire. \newline


\img{\rootImages/designer_workspace_new_button.png}{Premier bouton placé sur la fenêtre}{0.5}

\subsection{Renommer un widget}

Dans un souci de clarté pour la suite, nous vous invitons à tout de suite renommer l'élément avec un nom plus explicite. \newline
{\color{red}En effet, dans le programme python, le lien entre l'interface graphique et le programme sera fait par ce nom de widget.} \newline 
Pour cela, il faut aller dans la zone de droite qui contient l'arborescence des widgets de la fenêtre.

\img{\rootImages/designer_properties_rename_widget.png}{Emplacement pour renommer l'élément}{0.7}


Ici, le bouton "pushButton" a été renommé en "pb\_run" en double-cliquant sur "pushButton". Le texte passe en fond bleu, cela veut dire que vous pouvez renommer l'élément. La touche entrée valide le nouveau nom. \newline
Pour l'instant, veuillez ne pas toucher à la section de droite encadrée en rouge. Il s'agit des classes de chaque widgets. 

\img{\rootImages/designer_tree_forbidden_access.png}{Nom de classe à ne pas modifier}{0.7}


\subsection{Propriétés des widgets}

Une fois que le widget est placé, nous souhaiterions changer quelques unes de ses propriétés. \newline
Les propriétés d'un widgets sont disponibles dans le menu en bas à droite.
Pour afficher les propriétés d'un widget, il faut soit
\begin{enumerate}
    \item sélectionner le widget sur la zone de travail (clic-gauche)
    \item sélectionner le widget dans l'arborescence de la fenêtre (clic-gauche)
\end{enumerate}

\img{\rootImages/designer_properties_search_property.png}{Propriétés des widgets sélectionnés [encadré bleu]}{0.6}


\subsubsection{Définir la couleur d'un widget}
Pour changer la couleur d'arrière-plan d'un widget, il faut sélectionner la propriété "palette" puis cliquer dessus.

\img{\rootImages/designer_properties_color.png}{Couleurs des widgets}{0.5}


\subsubsection{Définir le contenu d'un widget}
Pour les widgets gérant un affichage pour l'utilisateur, toutes les informations se trouvent dans les propriétés avec un fond vert.\newline
Pour changer le texte du bouton par exemple, il faut modifier le champ "text".\newline

\img{\rootImages/designer_properties_text_content.png}{Contenu du widget "PushButton"}{0.6}


\section{Mise en forme d'un widget}

Maintenant que nous avons notre bouton, nous souhaiterions qu'il soit mieux placé et que sa taille s'adapte à celle de l'écran et des autres widgets. Pour cela, il faut utiliser les layouts, c'est à dire les widgets de mise en forme.
Ces widgets sont disponibles aux emplacements suivants : \newline

\img{\rootImages/designer_widget_layout.png}{Emplacements des layouts}{0.75}


Nous allons configurer notre zone de travail pour que tous les widgets adaptent leur taille à celle de l'écran.

Pour cela, il faut  d'abord qu'il y ait au moins un widget sur la fenêtre (un bouton par exemple) et que l'espace de travail soit sélectionné (Clic-gauche sur "MainWindow" dans l'arborescence). \newline
Ensuite, sélectionner le bouton "Mettre en page dans une grille" (raccourci "\textbf{ctrl+g}") dans la barre d'outil.

\img{\rootImages/designer_toolbar_grid_layout.png}{Configurer la fenêtre pour adapter son contenu}{1}


Et voila, notre widget prend automatiquement l'espace nécessaire au sein de la fenêtre. \newline


\img{\rootImages/designer_workspace_responsive_button.png}{Un bouton avec des dimensions automatiques}{0.6}



Si cette étape n'est pas faite, lorsque l'interface sera lancée, le widget aura toujours la même taille sur n'importe quel format d'écran (15", 17"...). L'avantage, c'est que cette étape n'est à faire qu'une seule fois, au début de tout nouveau projet. \newline

Nous allons placer un second bouton à coté du nôtre. On souhaite que les deux boutons aient les mêmes dimensions.

Il suffit de prendre un nouveau "pushButton" et de le glisser à coté du premier. Pour savoir l'emplacement du futur bouton, une ligne bleue apparaît au survol de la zone de travail avec le nouveau bouton.



\img{\rootImages/designer_worspace_blue_line.png}{Ligne de l'emplacement des widgets au survol}{0.7}

{\color{red}\bold{Le seconde bouton aura pour valeur "pb\_exit" (propriété du bouton dans l'éditeur de propriétés) et son nom dans l'arborescence sera "pb\_exit".\newline 
Notez également pour la suite que le premier premier bouton ("pb\_run") est appelé "pb\_run" dans l'arborescence. \newline 
Il est important de renommer un widget avec un nom pertinent dès l'ajout de ce dernier.}}
\img{\rootImages/designer_workspace_two_button.png}{Nos deux boutons}{0.6}

\subsection{Simuler l'interface graphique}

Pour visualiser un rendu du logiciel, il faut utiliser le raccourci clavier "\textbf{ctrl+r}". \newline Cela permet de donner une idée plus précise de l'interface.

\img{\rootImages/designer_workspace_run_two.png}{La fenêtre de simulation}{0.6}



Pour tester le résultat, nous vous invitons à dimensionner la fenêtre de simulation avec la souris. Vous pourrez constater que la taille des boutons s'adapte à la taille de la fenêtre.

\img{\rootImages/designer_workspace_responsive_two.png}{La fenêtre de simulation avec une taille variable}{0.6}

\section{Création du menu}

\subsection{Ajout de sous-menu}

Afin de proposer des outils aux futurs utilisateurs du logiciel, nous souhaitons créer un menu comportant des sous-menus.


\img{\rootImages/designer_context_qt_designer_menu.png}{Exemple de menu}{0.8}


Étant donné que la fenêtre est de type "MainWindow", un début de menu est déjà disponible. Pour créer le premier élément du menu, veuillez sélectionner le haut de l'espace de travail en cliquant sur "Éditer". \newline

\img{\rootImages/designer_workspace_add_menu.png}{Ajout de sous-menu}{0.8}


Une fois sélectionné, l'arrière-plan passe en bleu, vous pouvez éditer le nom du sous-menu puis valider avec la touche "entrée".

\subsection{Création des raccourcis clavier}

Il est possible de faire les raccourcis clavier du logiciel via l'interface QtDesigner. 


\section{Création d'une barre d'information}

Une barre d'information est disponible nativement pour afficher du texte sur les pages du logiciel. \newline Le widget associée est appelé \ib{QStatusBar}.



\img{\rootImages/designer_workspace_statusbar.png}{Ajout de barre d'information}{0.55}

La documentation est disponible à l'adresse suivante : \newline \url{https://doc.qt.io/qt-5/qstatusbar.html}

\chapter{Les principaux widgets}

Nous vous proposons de découvrir les principaux widgets et leurs propriétés spécifiques.
\newline
Nous vous recommandons de consulter la documentation Qt pour les différents widgets afin d'obtenir plus d'informations à leur sujets.

\section{Les widgets usuels}
\subsection{Widget QLabel}

Le widget \ib{QLabel} permet d'afficher du texte. 
Il est possible de rédiger du texte riche avec des tailles de polices, des polices et des couleurs différentes. \newline \newline

\img{\rootImages/designer_workspace_qlabel.png}{Un widget QLabel}{0.5}

La documentation du widget est disponible à l'adresse suivante : \newline  \url{https://doc.qt.io/qt-5/qlabel.html}


\subsection{Widget QLineEdit}

Le widget \ib{QLineEdit} permet à l'utilisateur de saisir du texte sur une seule ligne pour l'exploiter par la suite. 

\img{\rootImages/designer_workspace_lineedit.png}{Un widget QLineEdit}{0.8}

La documentation du widget est disponible à l'adresse suivante : \newline  \url{https://doc.qt.io/qt-5/qlineedit.html}


\subsection{Widget QComboBox}

Le widget \ib{QComboBox} est un outil de sélection d'un élément parmi une liste. \newline \newline
La documentation du widget est disponible à l'adresse suivante : \\  \url{https://doc.qt.io/qt-5/qcombobox.html} 

\img{\rootImages/designer_workspace_combobox.png}{Un widget QComboBox}{0.2}


\subsection{Widget QSpinBox}

Le widget \ib{QSpinBox} est une zone de saisie de nombre entier configurable.
Sa variante pour les nombres flottants est \ib{QDoubleSpinBox} 

\img{\rootImages/designer_workspace_spinbox.png}{Un widget QSpinBox}{0.8}
La documentation du widget est disponible à l'adresse suivante : \newline  \url{https://doc.qt.io/qt-5/qspinbox.html} 


\subsection{widget QTabWidget}

Le widget \ib{QTabWidget} permet de faire des onglets (un peu comme un navigateur internet)


\img{\rootImages/designer_workspace_tabwidget.png}{Un widget QtabWidget}{0.8} 
La documentation du widget est disponible à l'adresse suivante : \newline  \url{https://doc.qt.io/qt-5/qtabwidget.html} 

\section{Les boites de dialogue}

Il est parfois souhaitable d'afficher des informations à l'utilisateur par l'intermédiaire de boites de dialogue. \newline.

\subsection{QMessageBox}

Un type de boite de dialogue est la \ib{QMessageBox}. Cela permet d'afficher des informations de différentes natures.\newline

Le programme pour afficher ces fenêtres est expliqué, même si sa mise en place se fera plus tard. \newline
Il est conseillé de savoir que ces fenêtres existent car cela apporte des informations pour la supervision.\newline

Pour utiliser cette boite de dialogue, il faut importer le module suivant
\begin{lstlisting}[language=Python]
from PyQt5.QtWidgets import QMessageBox
\end{lstlisting}


\begin{enumerate}
    \item Une fenêtre d'information
    \img{\rootImages/designer_workspace_qmessagebox_information.png}{QMessageBox d'information}{0.8}
    L'instruction pour afficher la fenêtre est la suivante
    \begin{Python}
    QMessageBox.information(self, "Message PyQt5", "Ceci est une information")
    \end{Python}
    \item Une fenêtre d'avertissement
    \img{\rootImages/designer_workspace_qmessagebox_warning.png}{QMessageBox d'avertissement}{0.8}
    \begin{Python}
    QMessageBox.warning(self, "Message PyQt5", "Ceci est un avertissement")
    \end{Python}
    \item Une fenêtre d'erreur
    \img{\rootImages/designer_workspace_qmessagebox_critical.png}{QMessageBox d'erreur}{0.8}
    \begin{Python}
    QMessageBox.critical(self, "Message PyQt5", "Ceci est une erreur")
    \end{Python}
    \item Une fenêtre pour une question 
    \img{\rootImages/designer_workspace_qmessagebox_question.png}{QMessageBox pour une question}{0.8}
    \begin{Python}
    reponse = QMessageBox.question(self, "Message PyQt5", "Votre question ?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
    \end{Python}
    Le dernier argument représente la valeur par défaut lors de l'appui sur la touche "Entrée". \newline
    Pour traiter la réponse, il suffit de regarder la valeur de "reponse"
    \begin{Python}
    if(reponse==QMessageBox.Yes):
        print("Réponse Oui")
    else:
        print("Réponse Non")
    \end{Python}
\end{enumerate}





\chapter{Les interactions}

\section{Les signaux et slots}

Une fois que notre interface (\file{MainWindow.ui}) est réalisée, nous souhaiterions effectuer des actions lorsque l'utilisateur interagit avec des widgets. \newline \newline
Pour cela, QtDesigner est basé sur un modèle signaux/slots, c'est à dire qu'un évènement choisi parmi une liste permet d'appeler une fonction existante. \newline
Plus précisément, un signal est émit lorsque l'utilisateur effectue une action. Il ne reste plus qu'a récupérer ce signal, un peu comme le système d'exception en C++ (try/catch).
L'évènement est appelé "signal" et la fonction "slot". \newline \newline


\img{\rootImages/designer_slots.png}{Un signal et un slot sur un bouton}{0.4}

Dans l'exemple précédent, on observe que l'appui sur le bouton "button" déclenche la fonction "quit" de l'interface principale.

La mise en place effective du système de signaux/slots sera effectué dans la partie  \ref{exemple_signal} (\textit{Connexion d'un bouton})

\section{Génération des fichiers python}

Avant de programmer les signaux/slots, il convient de convertir notre fichier .ui en un fichier python exploitable par la suite. C'est l'utilitaire \bold{Pyuic5} qui va l'effectuer. \newline

Ce programme attend en entrée un fichier au format .ui et va sortir un fichier Python. La commande générique est la suivante : 

\begin{lstlisting}[language=bash]
pyuic5 -o fichier_python.py -x fichier_qtdesigner.ui
\end{lstlisting}

Le "-o" permet de préciser le fichier de sortie (output), c'est à dire le nom du fichier que nous souhaitons générer en python. \newline \newline
Le "-x" permet de préciser le fichier d'entrée (eXecutable) que nous souhaitons convertir. \newline \newline
Dans notre cas, nous allons faire la commande suivante, toujours dans notre répertoire \dir{Qtdesigner\_tuto}. \newline.
On n'oubliera pas de sauvegarder notre projet QtDesigner au préalable.
\begin{lstlisting}[language=bash]
pyuic5 -o MainWindow.py -x UI_demo.ui
\end{lstlisting}
Et voila, dans le dossier \dir{Qt\_tutoriel}, un fichier python appelé \file{UI\_MainWindow.py} vient d'être crée par pyuic. \newline

En  principe,  vous  n’aurez  jamais  besoin  de  modifier  le  fichier  python généré par Pyuic. En  effet, \textbf{{\color{red}ce  fichier  doit être généré à chaque  fois  que  vous  modifiez l’interface depuis QtDesigner}}, auquel cas vous ne constaterez aucun changement. \newline

Dans le cas de notre projet, faire une interface graphique avec QtDesigner est très graphique mais il est possible de faire l'interface directement en programmation Python. \newline
Pour vous en convaincre, voici un extrait de fichier python généré par Pyuic5 : \newline

\begin{lstlisting}[language=python]
class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(645, 434)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.sw_main = QtWidgets.QStackedWidget(self.centralwidget)
        self.sw_main.setObjectName("sw_main")
        self.page_4 = QtWidgets.QWidget()
        self.page_4.setObjectName("page_4")
\end{lstlisting}
Ainsi, si nous saisissons ces lignes dans un fichier Python, nous obtiendrons la même interface que celle réalisée avec QtDesigner, cependant, le temps de prise en main n'est pas le même. \newline

\section{Introduction à la Programmation Orientée Objet}
Afin de mieux comprendre le code généré et nécessaire à la création des interfaces graphiques sous QtDesigner, il convient d'expliquer quelques notions de \bold{Programmation Orientée Objet}. \\

La Programmation Orientée Objet (POO) est un concept de programmation qui vise à créer des "objets". \newline \newline
Ces objets possèdent des \textbf{attributs} (sorte de propriétés intrinsèques) et possèdent également des \textbf{méthodes}, c'est à dire des fonctions permettant d'interagir en interne et avec d'autres objets. \newline \newline
Prenons un exemple et considérons un objet "\ib{Véhicule}"\footnote{Par convention, les noms d'objets possèdent une majuscule.}. \newline
Cet objet possède des propriétés comme une couleur, des dimensions, un nombre de roues, etc. Ces élements forment les attributs de notre objet "\ib{Véhicule}". \newline


Maintenant, ou souhaite définir le comportement de notre objet "\ib{Véhicule}". Nous allons décréter que notre objet peut \italic{avancer}, \italic{reculer}, \italic{tourner à droite}, etc.
Ces actions forment les méthodes de notre objet.\newline \newline

 \img{\rootImages/designer_poo.png}{Un objet 'Véhicule'}{0.5}


La POO introduit en programmation la notion d'\textbf{héritage}. \newline
Cela signifie qu'un objet parent transmet tous ses attributs et ses méthodes à un ou plusieurs enfants. \newline
Par exemple, nous voulons créer une classe "\ib{Voiture}". Quelle est la manière la plus rapide de créer un objet Voiture ? Et bien il suffit de faire hériter notre objet "\ib{Véhicule}" à notre nouvel objet "\ib{Voiture}", ainsi, notre "\ib{Voiture}" aura une couleur, des dimensions, un nombre de roues, etc et pourra \italic{avancer}, \italic{reculer} et se déplacer de la même manière que le "\ib{Véhicule}". \newline Ce modèle est pertinent dans la mesure ou une voiture, un vélo ou même une trottinette ont des propriétés communes, ce sont tous des véhicules. \newline
Nous pourrions également appliquer le principe de POO à un objet "\ib{Animaux}" et créer des objets "\ib{Mammifères}", "\ib{Oiseaux}", "\ib{Poissons}" par héritage. \newline


\img{\rootImages/designer_poo_heritage.png}{L'héritage entre l'objet "\ib{Véhicule}" et l'objet \ib{Voiture}"}{0.5}


Qt utilise la POO car parmi tous les widgets, certains ont des propriétés communes (\ib{QSpinBox} et \ib{QDoubleSpinBox}) avec très peu de différences. Il est donc pertinent de partir d'un objet \textit{parent} (\ib{QWidget}) et de transmettre toutes les propriétés à ses \textit{enfants}, tout en modifiant parfois certaines de ses propriétés. \newline

Concrètement, la structure d'un objet est défini par une classe constituée de fonctions membres (méthodes) et de variables (attributs)

\section{Création d'un objet par héritage}

Pour résumer, l'utilitaire Pyuic créé un objet \lib{UI\_MainWindow} qui contient des attributs telles qu'une couleur d'arrière plan et des méthodes pour l'application. \newline
Nous voulons donc créer notre propre objet par héritage que nous appellerons \ib{MyObject} pour ajouter des fonctionnalités (méthodes et attributs) qui permettront notamment de gérer nos nouveaux boutons. \newline

Ouvrez un fichier que vous appellerez \file{MyModule.py}
Ensuite, importez le fichier Python généré par Pyuic avec l'instruction suivante :

\begin{lstlisting}[language=Python]
#On importe notre objet depuis le fichier UI_demo.py, généré par Pyuic
from UI_demo import Ui_MainWindow
\end{lstlisting}

puis importer les modules de base de PyQt :  
\begin{lstlisting}[language=Python]
from PyQt5 import QtCore, QtGui, QtWidgets
\end{lstlisting}

Maintenant, nous pouvons nous atteler à la création de notre classe \ib{MyObject} (structure de notre objet) qui hérite de \ib{QMainWindow}, afin d'exploiter notre interface graphique.


\begin{lstlisting}[language=Python]
class MyObject(QtWidgets.QMainWindow):
\end{lstlisting}

En programmation Python, l'héritage se définit lors de la création de la classe.\newline
Ici, avec la présence d'un argument entre les parenthèses, cela veut dire que \ib{MyObject} hérite de \ib{QtWidget.QMainWindow}.

La structure générale d'héritage en Python est donc la suivante : 
\begin{lstlisting}[language=Python]
class objet(parent):
\end{lstlisting}

\subsection{Déclaration du constructeur de classe}

Il nous faut maintenant définir un comportement lors de la création de notre objet. \newline
Pour cela, on va créer un constructeur de classe\footnote{En réalité un initialisateur, le constructeur est \_\_new\_\_.}
Le constructeur est une méthode appelée dès la création de l'objet, c'est même la première méthode qui crée l'objet. \newline
En python, le constructeur est repérée par le mot clé \bold{\_\_init\_\_} (préfixe et suffixe de init avec deux underscores).

Notre déclaration de constructeur de classe est donc la suivante : 

\begin{lstlisting}[language=Python]
    def __init__(self, parent = None):
\end{lstlisting}

On déclare que notre constructeur peut attendre en argument un parent mais que ce n'est pas obligatoire (présence d'un argument par défaut valant None). \newline Qt tolère des constructeurs avec aucun parent renseigné. \newline
L'argument \bold{self}\footnote{Le mot-clé self est utilisé par convention, mais on pourrai tout aussi bien choisir un autre mot.} est un argument obligatoire pour toute méthodes en python, il représente l'objet courant. 

\subsection{Définition du constructeur de classe}

Cependant, pour que notre objet possède les méthodes et attributs de l'objet \ib{QMainWindow} (héritage), il faut instancier notre objet parent, c'est à dire \ib{QMainWindow}.
Pour cela, on utilise la syntaxe suivante : 
\begin{lstlisting}[language=Python]
        super().__init__(parent)
\end{lstlisting}
L'instruction \italic{super.\_\_init\_\_(parent)} est un appel du constructeur parent. \newline
Et voila, notre future fenêtre aura toutes les méthodes et attributs de l'objet \ib{QMainWindow}, dont la méthode pour lancer l'interface et l'afficher. \newline.

Cependant, notre classe \ib{MyObject} ne possède pas les propriétés de notre interface créés sous QtDesigner. pour cela, il faut instancier l'objet importé depuis le fichier \file{UI\_demo.py} (module généré par Pyuic5) : 

\begin{lstlisting}[language=Python]
        self.__ui = UI_MainWindow()
\end{lstlisting}

Ici, \bold{self} fait toujours référence à notre objet courant (\ib{MyObject}) et le fait de mettre le symbole \bold{\_\_} en préfixe de variable permet à Python de considérer la variable comme étant privée. \newline 
Le fait de mettre une variable privée permet de rendre le code plus robuste dans la mesure ou le membre doit être manipulé par des méthodes spéciales.\newline


De ce fait, nous avons créer un membre de notre classe qui sera bientôt l'interface faite sous QtDesigner. \newline
Cependant, il est nécessaire de lier notre objet (\ib{MyObject}) à notre interface représentée par la variable membre \bold{self.\_ui} \newline
Il faut écrire la ligne suivante, ou \textit{self} est notre objet \ib{MyObject} : 

\begin{lstlisting}[language=Python]
        self.__ui.setuUI(self)
\end{lstlisting}



\bold{Et dans le fichier \file{MyModule.py}, vous devriez avoir les instructions suivantes :}

\begin{lstlisting}[language=Python]
from PyQt5 import QtCore, QtGui, QtWidgets
from UI_demo import UI\_MainWindow

#Objet MyObject qui hérite de QtWidgets.QMainWindow
class MyObject(QtWidgets.QMainWindow):
    
    #Constructeur de classe
    __init__(self, parent=None):
        
        #Instance de l'objet UI_MainWindow
        self._ui = UI_MainWindow()
        #On 'attache' l'interface à notre objet courant
        self.ui.setupUI(self)

\end{lstlisting}



\section{Lancement du programme}

\subsection{Création du fichier principal}

Nous avons actuellement créer un objet \ib{MyObject} qui est le rendu de l'interface faite sous QtDesigner. Nous souhaiterions l'exécuter comme un programme classique. \newline


Nous allons créer dans le \bold{répertorie \dir{Qt\_tutoriel}} un fichier \file{main.py} qui va représenter notre fichier principal, sous-entendu qui va lancer l'application à partir d'un terminal. \newline

\bold{Vous devriez obtenir, dans le répertoire \dir{Qt\_tutoriel} les fichiers suivants : }
\img{\rootImages/designer_files.png}{Fichiers dans le répertoire de travail}{0.4}

Dans le fichier \file{main.py}, il faut commencer par importer les modules courants de PyQt5 : 
\begin{lstlisting}[language=Python]
from PyQt5 import QtCore, QtGui, QtWidgets
import sys
\end{lstlisting}
Nous importerons également le module sys qui permet de gérer les sorties d'applications. \newline

Ici, nous allons importer notre classe \ib{MyObject} précédemment créée et contenue dans le fichier \file{MyModule.py}.
\begin{lstlisting}[language=Python]
from MyModule import MyObject
\end{lstlisting}


Ensuite, nous avons la ligne suivante pour autoriser à lancer le programme uniquement si ce dernier est lancé en tant que programme principal et non en tant que module.

\begin{lstlisting}[language=Python]
if(__name__ == "__main__"):
\end{lstlisting}


\begin{lstlisting}[language=Python]
    app = QtWidgets.QApplication(sys.argv)
    MyWindow = MyObject()
\end{lstlisting}

Ces deux lignes déclarent deux objets nommés "app" et "MyWindow" qui sont une instance respective de la classe \ib{QApplication} et \ib{MyObject}. \newline
Ici, "app" et "MainWindow" seront donc vus comme des entités ayant des propriétés.\newline
En argument de \ib{QtApplication}, nous avons "sys.argv", cela permet de transmettre les arguments de la ligne de commande, à l'image de la syntaxe suivante en C++ pour récupérer les arguments de la ligne de commande : \newline\newline
\begin{lstlisting}[language=bash]
   int main(int argc, char const *argv[]) {
        return 0;
   }
\end{lstlisting}


Maintenant, nous sommes en mesure  d'afficher la fenêtre de notre interface avec l'instruction suivante

\begin{lstlisting}[language=Python]
	MyWindow.show()
\end{lstlisting}

Maintenant que nous avons instancié notre objet \ib{MyObject}, la méthode \italic{show} permet uniquement d'afficher l'interface (mais pas de faire les traitements définit par l'utilisateur. \newline
Les traitements se font via la méthode "\italic{exec}" de l'objet "app".
Ainsi, on exécute les traitements de l'application et lorsque l'application se ferme (choix de l'utilisateur ou bien erreur de l'application), un code d'erreur est retourné à la fonction \italic{sys.exit()}.

\subsection{Lancement de l'interface}

Il ne vous reste plus qu'a saisir un terminal et de lancer la commande suivante : 
\begin{lstlisting}[language=bash]
	python main.py
\end{lstlisting}


Et voila, votre interface se lance.

%Image lancement


\section{Connexion d'un bouton}\label{exemple_signal}

Rappelez-vous, nous avons créée deux boutons (pb\_run et pb\_exit). Nous souhaiterions effectuer une action lors d'un appui sur les boutons. \newline
Nous allons donc connecter nos boutons par le système de signal/slot de Qt
Pour cela, \bold{nous nous plaçons dans le fichier d'interaction \file{MyModule.py}.}\newline

Il est généralement conseillé de faire les interactions dans le constructeur de la classe car cette fonction est appelée dès le lancement du programme. \newline
Avant de code, il convient de connaître l'évènement associé. Dans le cas d'un \ib{QPushButton}, le \textbf{signal} "clicked" est émis par le programme. \newline
Ce signal devra donc déclencher la fonction membre (slot) "\italic{test\_pb}" que nous allons coder à la suite du constructeur. \newline

Dans la fonction \_\_init\_\_, le code générique pour une interaction est  : \newline
\begin{lstlisting}[language=python]
	 self.__ui.objet.signal.connect(self.slot)
\end{lstlisting}
Où \textbf{objet}, \textbf{signal} et \textbf{slot} valent respectivement \textbf{pb\_run}, \textbf{clicked} et \textbf{test\_pb}
\begin{lstlisting}[language=python]
	 self.__ui.pb_run.clicked.connect(self.test_pb_run)
\end{lstlisting}
Tout au long du programme, le mot clé \bold{self\_\_ui} représentera l'objet courant dans le programme, c'est à dire la fenêtre de notre interface. \newline

\section{Ajout d'une fonction}

Une fois notre bouton connecté, il ne reste plus qu'a créer le slot (fonction appelée). \newline
Chaque ajout de fonction se fait à la suite du constructeur.
En python, une fonction se traduit par le mot-clé \textbf{def} suivi de son nom et du symbole ':' \newline
{\color{red}Dans le cas de la programmation python, il est impératif de mettre en premier argument le mot-clé \textbf{self} pour chaque nouvelle fonction-membre ajoutée.} \newline

Une mauvaise indentation provoquera une erreur d'exécution. 
Le mot clé "\textbf{def}" des fonction ajoutées sera toujours au même niveau d'indentation que le "\textbf{def}" du constructeur. (\_\_init\_\_)\newline

Notre fonction \italic{test\_pb\_run} se contentera d'afficher la bonne réception du signal. Vous devriez donc obtenir un code similaire : \newline

\begin{lstlisting}[language=Python]
def __init__(self,parent = None):
    super().__init__(self,parent)
    self.__ui = Ui_MainWindow()
    self.__ui.setupUi(self)
    
    #Connexion du bouton
    this.__ui.pb_run.clicked.connect(self.test_pb_run)
        
def test_pb(self):
    print("PushButton pb_run clicked")
        
\end{lstlisting}

je vous invite à lancer l'interface avec le fichier \file{main.py} et de constater le résultat dans le terminal lors de l'appui du bouton "pb\_run"
%image terminal python lancé
\section{Quelques signaux supplémentaires}

Pour connaître les signaux existants, on peut sélectionner le widget dans l'espace de travail puis avec un clic-droit, on sélectionne "Aller au slot". \newline
Tous les signaux associés au widget courant sont visibles.
Il est également possible de générer des signaux personnalisés (En savoir plus à l'adresse \url{https://www.pythoncentral.io/pysidepyqt-tutorial-creating-your-own-signals-and-slots/})

\img{\rootImages/designer_workspace_signals.png}{Les signaux pour une ComboBox}{0.6}


\chapter{Ajouts de widgets personnalisés}

Lors de la création de l'interface de supervision, nous serons amenés à utiliser des widgets qui nous avons crées. \newline
Ces widgets formerons des moteurs, vérins, voyant, etc. \\
Le fonctionnement de ces widgets est définis par le fichier \file{DynamicObject.py} au sein de la classe \ib{DynamicObject}.

\section{Importation d'un type de widget}

Nous allons vous montrez comment représenter un objet dynamique. Pour cette expérimentation nous présenterons l'utilisation d'un objet "vérin" mais le fonctionnement est similaire pour tous les autres objets.\\

Tout d'abord, ajoutez un widget sur la fenêtre d'interface.
On peut le renommer pour être plus explicite (fenêtre à droite).

Notre widget sera le parent de notre objet "vérin". Pour cela, on doit indiquer le fichier d'utilisation de notre classe \ib{DynamicObject}.

\img{\rootImages/programme_3.png}{Localisation du widget "Widget"}{0.25}

Puis on sélectionne notre widget et click Droit puis \textit{promote to}. 

\img{\rootImages/programme_4.png}{}{0.85}

On remplit nos champs comme ci-dessous:\\
-Promoted class name: \ib{DynamicObject}\\
-Header file: \file{ENIBSupervision/UI\_class/UI\_DynamicObject.py}

\img{\rootImages/programme_5.png}{Contenu des zones de saisi}{0.7}

On peut maintenant sauvegarder et fermer QtDesigner. \\

\bold{Cette étape est à faire une seule fois. Ensuite, pour chaque nouveau widget personnalisé, il faudra choisir dans \textit{promote to} la classe DynamicObject qui sera apparue.} \\

Pour les voyants qui serons abordés par la suite, il faudra promouvoir en \ib{IndicLight}

