\chapter{Introduction}

Ce document a pour but de vous initier à l'utilisation de PyQt5 à travers la réalisation d'un programme simple utilisant PyQt5 et les outils développés dans le module \lib{ENIBSupervision}.\newline
Ne seront pas abordés ici :
\begin{enumerate}
\item L'utilisation de QtDesigner
\item Le descriptif et le détail du code réalisé dans le module \lib{ENIBSupervision}
\end{enumerate}


La réalisation de ce projet a amené à la création d'un module \lib{ENIBSupervision} fournissant des outils facilitant la mise en oeuvre de logiciels de supervision en Python.\newline
Ce module propose des outils et une manière d'aborder la Supervision en Python, ce n'est qu'une manière parmi tant d'autres, le but était de simplifier le travail du programmeur en proposant des outils robustes et dont l'utilisation était accessible.


\chapter{Présentation}

\section{Types de variable principaux}

Cette section à pour but de faire une présentation rapide des types les plus importants disponibles dans ce module.

\subsection{Types non-graphiques}

\begin{enumerate}

\item \label{tag-presentation-PLCVar} \ib{PLCVar} \newline
Il s'agit du type principal de ce module, il représente une variable automate et possède les attributs nécessaires comme un \textbf{nom}, une \textbf{adresse}, une \textbf{description} etc... Ce type a été conçu pour fonctionner avec le type suivant : \ib{ModbusPLC}.\newline
Pour plus d'informations sur ce type, se référer à la documentation fournie en annexe.\newline
D'un point de vue organisation, le type \ib{PLCVar} est défini dans le sous-module \lib{PLC} puis dans le sous-module \lib{Variable}. \newline
Pour importer ce type, il faudra par exemple utiliser :
%"coloration" du code
\begin{lstlisting}[language=Python]
from ENIBSupervision.PLC.Variable import PLCVar
\end{lstlisting}

\item \ib{EventsLoop} \newline
Ce type permet la gestion pseudo-événementielle des variables. Son utilisation simplifie l'utilisation du type \ib{PLCVar} grâce à l'utilisation de fonctions connectées aux changements d'états d'une variable. Ce fonctionnement sera décrit en détail plus tard mais son utilisation est obligatoire pour profiter de tous les systèmes mis en place autour de cette gestion.\newline
Ce type permet de lancer en parallèle du programme principal une boucle qui cherchera à analyser l'état des variables dans l'automate à un intervalle de temps régulier. De la même manière, lorsque une variable est modifiée dans le programme et seulement si elle est modifiée, alors son état sera automatiquement envoyé vers l'automate. \newline
Si ce fonctionnement peut sembler compliqué, nous verrons dans la suite de ce document qu'il est en réalité extrêmement simple et que l'utilisation de ce type simplifie énormément la gestion de la communication avec l'automate. \newline
D'un point de vue organisation, le type \ib{EventsLoop} est défini dans le sous-module \lib{EventsLoop}.\newline
Pour plus d'informations sur ce type, se référer à la documentation fournie en annexe.\newline
Pour importer ce type, il faudra par exemple utiliser :
\begin{lstlisting}[language=Python]
from ENIBSupervision.EventsLoop import EventsLoop
\end{lstlisting}

\colors{red}{Il est important de noter que ce type n'est normalement pas à utiliser directement}. Il faut préférer l'utilisation du type \ib{ModbusPLC} qui gérera cette boucle événementielle automatiquement.

\item \label{tag-presentation-ModbusPLC} \ib{ModbusPLC} \newline
Il s'agit du second type principal de ce module, il représente un automate programmable industriel et possède les attributs nécessaires comme un \textbf{nom}, une \textbf{adresse IP}, une \textbf{description} etc... Ce type a été conçu pour fonctionner avec le type suivant : \ib{PLCVar}.\newline
Pour plus d'informations sur ce type, se référer à la documentation fournie en annexe.\newline
D'un point de vue organisation, le type \ib{ModbusPLC} est défini dans le sous-module \lib{PLC} puis dans le sous-module \lib{ModbusPLC}. \newline
Pour importer ce type, il faudra par exemple utiliser :
%"coloration" du code
\begin{lstlisting}[language=Python]
from ENIBSupervision.PLC.ModbusPLC import ModbusPLC
\end{lstlisting}

\end{enumerate}



\newpage



\subsection{Types graphiques}

\begin{enumerate}

\item \ib{AnimationTables}\newline
Ce type offre la possibilité de faire très facilement des tables d'animations à partir d'une liste de variables de type \ib{PLCVar}. Pour un bon fonctionnement des tables générées, il \colors{red}{est nécessaire} d'utiliser le type \ib{EventsLoop} ou \ib{ModbusPLC}.\newline
La fenêtre générée propose des fonctionnalités de forçage, d'actualisation automatique des valeurs lorsque couplé à une \ib{EventsLoop} ou un \ib{ModbusPMC}, d'affichage des tables d'entrées/sorties redimensionnables et la possibilité de la "docker" sur une fenêtre principale de Qt \href{https://doc.qt.io/qt-5/qmainwindow.html}{QMainWindow}.\newline
D'un point de vue organisation, le type \ib{AnimationTables} est défini dans le sous-module \lib{UI\_class} puis dans le sous-module \newline \lib{UI\_AnimationTables}.\newline
Pour plus d'informations sur ce type, se référer à la documentation fournie en annexe.\newline
Pour importer ce type, il faudra par exemple utiliser :
\begin{lstlisting}[language=Python]
from ENIBSupervision.UI_class.UI_AnimationTables import AnimationTables
\end{lstlisting}
Voici un exemple de tables que l'on peut obtenir :
\img{\rootImages/enibSup_window_animationTablesExample.png}{Exemple de tables d'animations}{0.4}


\item \ib{DynamicObject}\newline
Ce type offre la possibilité de représenter très facilement des éléments d'une partie opérative tels que des vérins ou des moteurs.\newline
D'un point de vue organisation, le type \ib{DynamicObject} est défini dans le sous-module \lib{UI\_class} puis dans le sous-module \newline \lib{UI\_DynamicObject}.\newline
Pour plus d'informations sur ce type, se référer à la documentation fournie en annexe.\newline
Pour importer ce type, il faudra par exemple utiliser :
\begin{lstlisting}[language=Python]
from ENIBSupervision.UI_class.UI_DynamicObject import DynamicObject
\end{lstlisting}
Voici un exemple de widget que l'on peut obtenir :
\img{\rootImages/enibSup_DynamicObject_moteur.png}{Exemple de résultat avec un moteur}{0.4}
\img{\rootImages/enibSup_DynamicObject_verin.png}{Exemple de résultat avec un vérin}{0.4}

\newpage

\item \ib{IndicLight}\newline
Ce type offre la possibilité de représenter très facilement des voyants avec un nombre d'états infinis.\newline
D'un point de vue organisation, le type \ib{IndicLight} est défini dans le sous-module \lib{UI\_class} puis dans le sous-module \newline \lib{UI\_IndicLight}.\newline
Pour plus d'informations sur ce type, se référer à la documentation fournie en annexe.\newline
Pour importer ce type, il faudra par exemple utiliser :
\begin{lstlisting}[language=Python]
from ENIBSupervision.UI_class.UI_IndicLight import IndicLight
\end{lstlisting}
Voici un exemple de voyants que l'on peut obtenir :
\img{\rootImages/enibSup_IndicLight.png}{Exemple de résultat avec deux voyants dans deux états différents}{0.4}

\end{enumerate}




\chapter{Réalisation d'un programme élémentaire}

Nous allons aborder dans ce chapitre la création d'un programme de base en utilisant PyQt5. A la fin de ce chapitre, vous serez en mesure de créer et d'afficher une fenêtre principale basique.\\

Il est très vivement conseillé de lire l'introduction à PyQt5 et QtDesigner avant de s'attaquer à cette partie. Aussi, il est considéré que les différents outils nécessaires sont déjà installés.



\section{Architecture type d'un programme}

Cette section a pour but de présenter \textbf{une} manière parmi tant d'autres d'organiser un programme de ce type utilisant Qt comme bibliothèque graphique.

L'utilisation de Qt en Python (c'est originellement une bibliothèque C++) impose certaines contraintes. En effet, cela impose la création de fichiers \textbf{*.ui}, l'utilisation de fichiers Python automatiquement générés et l'utilisation de fichiers rédigés par un programmeur.\newline
L'organisation qui va être présentée a l'avantage de séparer ces trois "types" de fichiers et de permettre l'utilisation d'outils déjà rédigés.

\subsection{Création d'un dossier de projet}

En premier lieu, nous allons créer un dossier de projet. On l'appellera la \textbf{racine du projet}. Ce dossier contiendra tous les fichiers nécessaires au programme.\newline
Pour notre exemple, je vais nommer le dossier "\dir{SupEx}".\newline

\subsection{Contenu essentiel de la racine du projet}

Nous pouvons ensuite copier le dossier \dir{ENIBSupervision} fourni dans la racine du projet.\newline

Dans la racine du projet, nous allons ensuite séparer les trois types de fichiers mentionnés plus haut (QtDesigner,python générés,python rédigés). Pour ce faire, nous allons créer  trois nouveaux dossiers. Pour pouvoir utiliser un script que nous verrons juste après, il sera nécessaire de les nommer comme suit :
\begin{enumerate}

\item \dir{UI\_formFiles} : Ce dossier contiendra les fichiers d'interfaces graphiques créés avec QtDesigner (fichiers \textbf{*.ui})\newline

\item \dir{UI\_pyFiles} : Ce dossier contiendra les fichiers Python générés depuis les fichiers \textbf{*.ui} du dossier \dir{UI\_formFiles} à l'aide de l'outil \textbf{pyuic}.\newline
C'est d'ailleurs ici que rentre en jeu un petit script que vous pouvez trouver dans le dossier du module \lib{ENIBSupervision}. Ce script python se nomme "\file{scriptExport.py}". Son fonctionnement est très simple, il fournit une fonction permettant de convertir automatiquement tous les fichiers \file{*.ui} d'un dossier en fichier \file{*.py} dans autre dossier. Consultez la documentation de ce module pour plus d'informations.\newline
Si vous lancez le script Python, il cherchera par défaut à appliquer ces traitements sur les dossiers mentionnés soit \dir{UI\_formFiles} et \dir{UI\_pyFiles}.

\item \dir{UI\_class} : Ce nom n'est ici d'aucune importance, vous pouvez le modifier comme bon vous semble sans avoir quoique ce soit d'autre à modifier.\newline
Ce dossier contiendra les fichiers de code Python que vous aurez rédigés et qui serviront dans votre programme pour créer des interfaces graphiques.

\end{enumerate}

Encore une fois, il s'agit de propositions, libre à vous de les renommer comme bon vous semble mais il vous faudra certainement adapter votre code à certains endroits.

\subsection{Fichier principal du programme}

N'oublions pas de rajouter le fichier qui servira à lancer le programme.Nous l'appellerons le fichier principal ou "main" en anglais.\newline
Ainsi, nous pouvons créer un fichier "\file{main.py}" avec son contenu essentiel dans la racine du projet :

\begin{Python}
# -*- coding: utf-8 -*-
#on explicite l'encodage du fichier

#importation des modules nécessaires à Qt
import sys
from PyQt5 import QtCore, QtGui, QtWidgets


if(__name__ == "__main__"): #si c'est ce module qui est lancé directement

	#code du programme

\end{Python}

\subsection{Résultat}

Vous devriez maintenant avoir dans votre racine du projet créé précédemment, quelque chose ressemblant fortement à ceci :

\img{\rootImages/enibSup_window_explorer_projectRoot.png}{Illustration d'une racine de projet}{0.4}

%new section

\section{La fenêtre principale}

\subsection{Création de l'interface graphique}

Nous utiliserons ici QtDesigner et PyQt5 avec leurs outils respectifs, si vous n'avez pas encore étudié leur fonctionnement, je vous invite à vous y intéresser avant de commencer cette section. Une annexe à ce sujet est disponible.\newline
En effet, même si nous rappellerons ici l'essentiel, vous aurez certainement besoin de plus de connaissances pour être à même de concevoir une interface vraiment utilisable.

\subsubsection{Lancement de QtDesigner}

Il est possible que ce logiciel ne soit pas "facilement" accessible. Ainsi, nous vous invitons à suivre la procédure suivante :
\begin{enumerate}
\item Ouvrir une console windows/Un terminal linux
\item Lancer QtDesigner par la commande suivante :
\begin{lstlisting}[language=bash]
designer
\end{lstlisting}
\end{enumerate}

Si vous avez installés les outils nécessaires, cette commande devrait vous lancer le logiciel et vous épargner de longues minutes de recherche du dossier d'installation.

\subsubsection{Choix de l'interface}

A l'ouverture du logiciel, vous devriez arriver sur une page vous demandant de choisir le type de "\bold{formulaire}" que vous voulez créer.\newline
Puisque nous voulons réaliser une fenêtre principale, nous sélectionnerons en toute logique le type "\ib{\colors{red}{MainWindow}}" :

\img{\rootImages/enibSup_window_designerWidgetSelection_MainWindow.png}{Sélection du type d'interface voulue}{0.3}

Je laisse à votre charge de réaliser le contenu de la fenêtre : pour cet exemple simple, nous allons simplement disposer un bouton dans la fenêtre et l'organiser dans un layout simple.\newline
Vous devriez obtenir à la fin une fenêtre ressemblant à ceci :

\img{\rootImages/enibSup_window_MainWindowExample.png}{Fenêtre principale de l'exemple}{0.4}

N'oubliez pas de sauvegarder votre réalisation
\footnote{Profitons-en ici pour rappeler que nous ne sauvegardons jamais assez. Dès que vous le pouvez, sauvegardez, la combinaison \bold{\colors{red}{Ctrl+S}} doit devenir un réflexe. Souvenez-vous que vous pouvez perdre tout votre travail sur un simple bug.}
dans le dossier adapté, soit \file{UI\_formFiles} dans la racine de votre projet. Pour cet exemple, je la nommerai \file{UI\_MainWindow.ui}\newline
Vous avez maintenant une interface graphique "dessinée" facilement. Il ne reste plus qu'à l'exploiter.


%End section

\section{Export de l'interface}

Pour pouvoir exploiter l'interface que nous avons créé, il nous faut convertir le fichier \file{*.ui} en fichier Python utilisable.\newline
Ceci est permis grâce à l'outil \italic{\bold{pyuic5}}.\newline
J'ai déjà mentionné un script permettant de réaliser cet export automatiquement. Nous allons nous en servir. Si vous avez suivi la section "\bold{Architecture type d'un programme}", vous devriez avoir dans la racine du projet ce script sous forme d'un fichier Python nommé \file{scriptExport.py}. Il vous suffit de le lancer. Si vous le lancez depuis un terminal
\footnote
{
Nous vous conseillons plutôt de manière générale de lancer les différents programmes python depuis un terminal lors du développement. Cela vous permet d'afficher facilement des informations pour contrôler la bonne exécution du programme lors du débogage.
}
, vous aurez le détail des fichiers exportés.\newline

\img{\rootImages/enibSup_window_explorer_projectRoot_scriptExport.png}{Script d'export dans la racine du projet}{0.4}

Une fois le script lancé, vérifiez que le dossier \file{UI\_pyFiles} contient bien un fichier dont le nom est identique au fichier \bold{*.ui} que vous avez édité précédemment. Notez que si vous avez enregistré un fichier avec un nom commençant par le préfixe \italic{UI\_}, celui-ci a été supprimé, c'est un comportement voulu. Libre à vous de modifier ce script simpliste.

\img{\rootImages/enibSup_window_explorer_UIPyFiles_mainWindow.png}{Fichier \bold{*.ui} exporté en fichier \bold{*.py}}{0.4}

%End section

\section{Exploitation de l'interface en python}

\subsection{Pré-requis}

Nous avons maintenant toutes les clefs en main pour faire un programme minimal exploitant cette interface.\newline
Nous allons nous rendre dans le dossier \file{UI\_class} dans la racine du projet pour créer un nouveau fichier qui correspondra au module contenant la définition de notre fenêtre principale. (Le coeur du programme)\newline
Pour ma part, ce module portera le même nom que son fichier \file{*.ui} associé soit \file{UI\_MainWindow.py}.

\img{\rootImages/enibSup_window_explorer_UIClass_basic.png}{Contenu du dossier \dir{UI\_class} en l'état}{0.4}

\subsection{Rédaction du code de la fenêtre principale}

Tout d'abord, n'oublions pas la ligne traditionnelle d'en-tête d'un fichier Python :
\begin{Python}
# -*- coding: utf-8 -*-
#on explicite l'encodage du fichier
\end{Python}
Puis l'importation des modules nécessaires à l'utilisation de PyQt
\begin{Python}
#importation des modules nécessaires à Qt
from PyQt5 import QtCore, QtGui, QtWidgets
\end{Python}

Ensuite, attaquons-nous au plus délicat.\newline
Afin d'augmenter notre liberté de programmation, nous allons ici déclarer notre propre \bold{classe} qui va permettre l'exploitation de l'interface générée précédemment. Nous utiliserons ici des concepts de Programmation Orientée Object qui ne sont abordés normalement qu'en S5 à l'Enib\footnote{Cette notion est abordée dans le chapitre 7.3}. Mais pas d'inquiétude, cela ne vous empêchera pas de mener à bien votre projet.\newline
La déclaration de notre classe qui  va représenter notre fenêtre principale nécessite l'importation du module Python généré depuis le fichier QtDesigner. Si vous avez utilisés les mêmes noms que ceux utilisés dans ce tutoriel, la ligne permettant l'importation de ce module sera celle-ci :
\begin{Python}
from UI_pyFiles.MainWindow import Ui_MainWindow
\end{Python}
Dans le cas contraire, c'est à vous que revient la responsabilité de faire les modifications nécessaires.\\ 


Pour le moment, votre fichier doit donc ressembler à ceci
\footnote{ Profitons-en pour vous rappeler de sauvegarder régulièrement votre travail, \colors{red}{\bold{Ctrl+S}} n'est pas un raccourci compliqué à retenir et peut vous épargner bien des déconvenues.}
:
\begin{Python}
# -*- coding: utf-8 -*-
#on explicite l’encodage du fichier

#importation des modules nécessaires à Qt
from PyQt5 import QtCore, QtGui, QtWidgets

#importation du module nécessaire à la création de notre fenêtre principale
from UI_pyFiles.MainWindow import Ui_MainWindow
\end{Python}


Maintenant, rentrons au coeur du sujet. Nous pouvons dorénavant déclarer notre classe sans que Python ne nous insulte copieusement lorsque nous lancerons le programme
\footnote{Notons que pour le moment, nous ne pouvons pas vraiment tester le programme dans le sens où il ne fait rien et notre fichier main n'est pas encore préparé. Exécuter le fichier seul en dehors de la racine du projet provoquera certainement des erreurs dans les importations (il faudrait donc l'exécuter depuis le fichier \file{main.py} par exemple pour éviter les problèmes).\newline Rappelons ici que plus vous exécuterez votre code souvent, moins vous aurez d'erreurs à corriger à la fois. N'hésitez pas à l'exécuter dès que vous le pouvez (Nous verrons cela ensemble dans quelques temps).}.\newline
La déclaration de notre classe se fera de la manière suivante :
\begin{Python}
class MainWindow(QtWidgets.QMainWindow):
    #code
\end{Python}
Où \ib{MainWindow} correspond au type représentant notre fenêtre principale
\footnote
{Vous pouvez modifier ce nom comme bon vous semble mais que celui-ci a l'avantage indéniable d'être explicite.}
et la portion de code \ib{(QtWidgets.QMainWindow)} permet d'indiquer à Python que notre type \ib{MainWindow} \italic{hérite} des propriétés du type \ib{QtWidgets.QMainWindow}.\newline
Concrètement, notre type pourra faire tout ce que faisait une \ib{QMainWindow} du module \ib{QtWidgets} plus ce que nous lui apprendrons.


\subsubsection{Constructeur de notre classe}

Tout comme en C++, nous pouvons définir un constructeur
\footnote{Une fonction membre \_\_init\_\_ en Python n'est pas vraiment un constructeur mais un "initialiseur". Cependant, pour simplifier la compréhension nous utiliserons ici abusivement le terme constructeur. Pour un peu plus d'information à ce sujet : \url{https://www.geeksforgeeks.org/__new__-in-python/}}
pour notre classe. Celui-ci sera appelé lors de l'initialisation d'un nouvel objet de notre type \ib{MainWindow}.\newline
En Python, le constructeur d'une classe se définit de la manière suivante :
\begin{Python}
def __init__(self):
    #code
\end{Python}
Et il sera toujours définit de cette manière (aux paramètres près).\\

Profitons de ce moment pour attirer votre attention sur le paramètre \colors{red}{\ib{self}} qui est un paramètre particulièrement important\footnote{Pour plus d'informations sur self : \url{https://www.geeksforgeeks.org/self-in-python-class/}}. Il représente l'instance de la classe. Pour avoir un équivalent dans un langage mieux connu des élèves, c'est un peu comme le mot-clé \ib{this} en c++. Sauf qu'en python \colors{red}{\ib{self}} est beaucoup plus important, nous verrons après pourquoi.\newline
Ce paramètre \colors{red}{\bold{doit}} figurer dans tous les prototypes des fonctions membres d'une classe.\\

Revenons-en au constructeur de notre classe \ib{MainWindow}, il existe avec Qt un système de widget parent/enfant trop complexe à expliquer ici. Le principal est de savoir que ce système existe et que avec Qt, la plupart des widgets\footnote{À noter qu'une \ib{QMainWindow} est aussi un widget} instanciés doivent avoir un parent (pour des raisons trop complexes à aborder ici encore une fois). Ce qui implique que tous les widgets aient dans leurs constructeurs un paramètre représentant un potentiel widget parent.\vskip 0cm %Nouveau paragraphe sans saut de ligne
Nous devrions donc en toute rigueur laisser au programmeur (vous) la possibilité d'initialiser son type avec un widget parent (Même si c'est hautement improbable dans le cas d'une fenêtre principale puisque ce sera le premier widget que nous allons créer). Mais puisque c'est une bonne habitude à prendre quand l'on programme en utilisant des widgets et Qt, nous allons le faire.\newline
Ceci se traduit simplement par un paramètre \italic{parent} dans le constructeur pouvant représenter le parent de notre type héritant d'un widget Qt.\newline
Concrètement, le prototype de notre constructeur ressemblera à ceci:
\begin{Python}
def __init__(self,parent = None):
\end{Python}
Le morceau de code "\ib{parent = None}" permet de signaler à Python quand dans le cas où le programmeur ne spécifierait pas ce paramètre, sa valeur serait "\bold{None}", on appelle ça une \colors{red}{valeur par défaut}.\newline
Puisque tous les widgets de Qt autorisent leurs instanciations sans parent spécifié (même si ce n'est pas une bonne pratique), il sera d'usage de proposer une valeur par défaut "\ib{None}" au paramètre "\ib{parent}" d'un constructeur d'un type héritant d'un widget de Qt.\\

Nous avons la déclaration de notre constructeur, nous devons maintenant le définir.\newline
La première chose à faire est d'appeler le constructeur du type hérité, il s'agit d'une forme de délégation. Et pour cela, Python vous fournit un outil tout fait : la fonction "\bold{super()}"
\footnote
{En réalité, la fonction "\bold{super()}" est beaucoup plus complexe que cela, si vous voulez en savoir plus : \url{https://www.stashofcode.fr/comment-marche-fonction-super-de-python/}}
. Son utilisation est la suivante (Le constructeur complet est écrit dans le code ci-dessous) :
\begin{Python}
def __init__(self,parent = None):
		super().__init__(parent)
\end{Python}
Dans notre cas, en faisant cela, nous initialisons notre class en appelant le constructeur de \href{https://doc.qt.io/qt-5/qmainwindow.html}{QMainWindow}\newpage


Pour une meilleure vision d'ensemble, voici à quoi devrait ressembler votre fichier de définition de votre classe \ib{MainWindow} :
\begin{Python}
# -*- coding: utf-8 -*-
#on explicite l’encodage du fichier

#importation des modules nécessaires à Qt
from PyQt5 import QtCore, QtGui, QtWidgets

#importation du module nécessaire à la création de notre fenêtre principale
from UI_pyFiles.MainWindow import Ui_MainWindow

class MainWindow(QtWidgets.QMainWindow): #déclaration de la class MainWindow

	#déclaration du constructeur avec un possible parent
	def __init__(self,parent = None):
		#on appelle le constructeur de la class parent
		super().__init__(parent)
\end{Python}

En l'état, nous avons une fenêtre vide. Nous allons maintenant voir comment utiliser l'interface que nous avons précédemment créé avec QtDesigner.\newline
C'est ici que notre ligne d'importation du module généré par \bold{pyuic5} va nous servir. Si vous ne vous en souvenez pas, c'est celle-ci :
\begin{Python}
from UI_pyFiles.MainWindow import Ui_MainWindow
\end{Python}
La première étape est de d'initialiser une variable membre "interface graphique" dont le type portera le nom du fichier \ib{*.ui} que vous avez créé.\newline
C'est cette variable qui nous permettra d'accéder aux différents éléments de l'interface que nous avons mis en place.\newline
Puisque nous n'avons pas à accéder à ces éléments en dehors de notre classe, cette variable sera privée.\newline
En pratique, cela se traduit par l'instruction suivante :
\begin{Python}
self.__ui = Ui_MainWindow()
\end{Python}
Explications : 
Pour accéder à des variables membres de la classe, il est nécessaire en Python de \colors{red}{systématiquement} utiliser "\colors{blue}{\ib{self.}}"
\footnote{Vous l'oublierez certainement à plusieurs reprise. En cas d'oubli, vous ne ferez qu'accéder à des variables locales ce qui amènera à des erreurs peu explicites}. Dans notre cas, nous créons une variable membre de nom \italic{\_\_ui}.\newline
Ce nom n'a pas été choisi par hasard, en Python, toute variable membre dont le nom commence par "\_\_" est une variable privée. Quant au nom en lui même,  "\colors{green}{\bold{ui}}", il s'agit de l'abréviation anglaise de \bold{UserInterface}.\newline
Cette variable est initialisée avec le type de l'interface graphique que nous avons conçu plus tôt.\newline
\bold{En résumé} : Nous créons une variable membre privée dans notre classe qui nous permettra d'accéder à l'interface graphique.\\

Il faut maintenant lier notre interface à notre fenêtre principale. Pour le moment, les deux existent mais rien ne les relie si ce n'est que l'UI est une variable membre de notre classe \ib{MainWindow}. Hélas, ce n'est pas suffisant. Nous devons appeler une fonction pour dire que notre interface s'applique à notre fenêtre. Cette fonction est la suivante :
\begin{Python}
self.__ui.setupUi(self)
\end{Python}
Il n'y a pas grand chose à dire dessus, elle ne fait qu'affecter l'interface à notre fenêtre, c'est une fonction de la bibliothèque Qt.\\

Voici à quoi devrait maintenant ressembler votre fichier de définition de notre type \ib{MainWindow} :
\begin{Python}
# -*- coding: utf-8 -*-
#on explicite l’encodage du fichier

#importation des modules nécessaires à Qt
from PyQt5 import QtCore, QtGui, QtWidgets

#importation du module nécessaire à la création de notre fenêtre principale
from UI_pyFiles.MainWindow import Ui_MainWindow

class MainWindow(QtWidgets.QMainWindow): #déclaration de la class MainWindow

	#déclaration du constructeur avec un possible parent
	def __init__(self,parent = None):
		#on appelle le constructeur de la class parent
		super().__init__(parent)

		#initialisation de l'interface graphique
		self.__ui = Ui_MainWindow()
		#Affectation de l'interface à notre fenêtre principale
		self.__ui.setupUi(self)
\end{Python}


Notre fenêtre principale est maintenant prête à être affichée, c'est ce que nous allons aborder dans la section suivante.


\subsection{Affichage de notre fenêtre principale.}

Nous allons délaisser notre fichier \file{UI\_MainWindow.py} au profit du fichier \file{main.py}. En effet, si la définition de la fenêtre s'est faite dans un fichier, l'initialisation et l'affichage de notre fenêtre \underline{principale} se fera depuis le fichier \file{main.py}.\\

Pour le moment, le contenu du fichier \file{main.py} doit ressembler à ceci :
\begin{Python}
# -*- coding: utf-8 -*-
#on  explicite l’encodage  du  fichier

#importation des modules nécessaires à Qt
import sys
from PyQt5 import QtCore, QtGui, QtWidgets

#importation des modules d'interfaces graphiques créés
from UI_class.UI_MainWindow import MainWindow


if(__name__ == "__main__"): #si c'est ce module qui est lancé directement

	#code
\end{Python}

\subsubsection{Création d'une application Qt}

L'utilisation de Qt impose l'initialisation et l'exécution d'une "application" Qt pour faire fonctionner tous les éléments. C'est ce que nous allons voir ici.\newline
C'est la première étape, nous allons déclarer une application Qt, cela se fait assez simplement :
\begin{Python}
app = QtWidgets.QApplication(sys.argv)
\end{Python}
Très succinctement, nous déclarons ici une \ib{QApplication} en lui passant en paramètre les arguments fournis au programme
\footnote{Il s'agit en réalité des arguments de la ligne de commande (plus d'informations ici : \url{https://en.wikipedia.org/wiki/Command-line_argument_parsing}}.\newline
Maintenant que nous avons notre application, nous pouvons l'exécuter. Nous le ferons d'une manière assez condensée avec l'instruction suivante :
\begin{Python}
sys.exit(app.exec())
\end{Python}
Cette ligne réalise en réalité deux opérations :
\begin{enumerate}
    \item \bold{Éxécution de l'application} : ceci est réalisé par l'appel de de "\italic{app.exec()}". Cette fonction retourne un "statut d'exécution de l'application Qt"\footnote{Il s'agit d'un code permettant de savoir si un programme s'est exécuté correctement.\newline
    Plus d'informations ici : \url{https://en.wikipedia.org/wiki/Return_statement}}.
    
    \item \bold{Quitter le programme python} : ceci est réalisé par la fonction "\italic{sys.exit()}"\footnote{Plus d'informations sur cette fonction ici \url{https://python101.pythonlibrary.org/chapter20_sys.html}} qui prend en argument un statut d'exécution à retourner au système d'exploitation.
\end{enumerate}
L'utilisation de "\italic{app.exec()}" en argument de "\italic{sys.exit()}" permet donc de faire quitter le programme Python en renvoyant au système le statut d'exécution de l'application Qt lorsque celle-ci est terminée.\\

Vous devriez dorénavant avoir un code ressemblant à ceci :
\begin{Python}
#si c'est ce module qui est lancé directement
if(__name__ == "__main__"):

	#déclaration de l'application Qt
	app = QtWidgets.QApplication(sys.argv)
	#exécution de l'application Qt
	sys.exit(app.exec())
\end{Python}
Le problème étant que ce code n'utilise pas encore notre fenêtre principale que nous avons définit plus tôt.\newline
Ce sera donc la prochaine étape, déclarer et afficher notre fenêtre.

\subsubsection{Affichage de la fenêtre principale}

Nous avons créé notre type \ib{MainWindow} pour pouvoir manipuler une fenêtre principale, il nous faut maintenant l'utiliser.\newline
Tout le code que nous allons écrire sera placé avant la ligne
\begin{Python}
    #exécution de l'application Qt
	sys.exit(app.exec())
\end{Python}
Puisque celle-ci signe la fin du programme. Tout le code placé après ne sera pas exécuté.\\

Pour cela, il nous suffit de déclarer une variable de notre type \ib{MainWindow} puis de l'afficher.\newline
Vérifiez tout d'abord que vous importez bien le type que nous avons créé depuis le bon module :
\begin{Python}
#importation du module d'interface graphique créé
from UI_class.UI_MainWindow import MainWindow
\end{Python}
Si c'est déjà le cas, vous n'avez plus qu'à déclarer une variable utilisant ce type, par exemple :
\begin{Python}
mainWindow = MainWindow()
\end{Python}
Et pour la voir apparaître, il suffit d'appeler une fonction : "\italic{show()}" sur cette variable, ce qui donne :
\begin{Python}
mainWindow.show()
\end{Python}



\subsubsection{Lancement du programme}
\label{tag-startProgFromCmdLine}
Il est maintenant possible de lancer notre programme et de voir le résultat de tout ce que nous avons fait jusqu'à maintenant.\newline
Pour cela, comme cela a été conseillé auparavant, nous passerons par un terminal pour lancer le programme en suivant ces étapes :
\begin{enumerate}
\item Lancez un terminal
    
\item Placez vous dans la racine du projet (à l'aide de la commande \colors{blue}{\bold{cd}})
    
\item Lancez le programme en utilisant la commande suivante qui fera exécuter le fichier "\bold{main.py}" :
\begin{Python}
    python main.py
\end{Python}
\end{enumerate}



Dans le cas où Python ne trouverait aucune erreur, vous devriez voir apparaître à l'écran quelque chose de ce type :

\img{\rootImages/enibSup_window_firstMainWindow.png}{Résultat de l'exécution de votre programme}{0.27}




\chapter{Réalisation d'un programme ENIBSupervision}

Dans ce chapitre, nous travaillerons principalement dans le fichier de définition de la fenêtre principale du programme. Dans notre cas il s'agit du fichier \ib{UI\_MainWindow.py}.\\




\section{Variable automate}

Les outils développés dans le module \bold{enibSupervision} ont été conçus pour fonctionner avec une liste de variables de type \ib{PLCVar}.\\

Dans notre cas, je vous invite à stocker cette liste de variables en tant que variable membre de notre classe \ib{MainWindow} (qui est maintenant au coeur de notre programme) afin que nous puissions nous en servir à d'autres occasions

\subsection{Pré-requis}

Afin de pouvoir utiliser le type \ib{PLCVar}, vous aurez besoin de l'importer, ceci peut se faire de la manière suivate :
\begin{Python}
from ENIBSupervision.PLC.Variable import PLCVar
\end{Python}

\subsection{Fonction d'initialisation}

Je vous propose de créer une fonction qui nous servira à initialiser nos variables. Bien que ce ne soit pas une obligation, cela améliorera la lisibilité de notre code.\newline
Cette fonction sera un membre de la classe \ib{MainWindow}.\newline
Il suffit pour cela de déclarer la fonction après le constructeur de la classe.\newline
Je vous propose d'appeler cette fonction \italic{initVarList}.\\

\begin{Python}

    def __init___(self, parent=None):
        # on appelle le constructeur de la class parent
        super().__init__(parent)
        #initialisation de l’interface graphique
        self.__ui = Ui_MainWindow()
        # Affectation de l’interface à notre fenêtre principale
        self.__ui.setupUi(self)    

    def initVarList(self):

        varList = []  #initialisation de la liste de variables
        #Déclaration des variables effectuées ici
        return varList  # on retourne la liste de variables

\end{Python}

Cette méthode retournera donc une liste contenant toutes les variables de l'automate.\\


\subsection{Ajout de l'automate}

\bold{Étant donné qu'il est possible de définir plusieurs automates avec le logiciel}, nous allons déclarer une liste dans le constructeur qui contiendra les potentiels automates, dont celui du projet. \\
La liste de variables ainsi obtenue doit être stockée dans une variable membre de notre classe \ib{MainWindow}\\
Pour le code d'exemple, nous allons créer deux automates appelés "Automate Test 0" et "Automate Test 1" depuis le constructeur de la classe.\\

Le premier argument passé est l'adresse IP de l'automate, le second le nom et le dernier concerne la liste des variables associées.

\begin{Python}

	# déclaration du constructeur avec un possible parent
	def __init__(self, parent=None):
		# on appelle le constructeur de la class parent
		super().__init__(parent)

		# initialisation de l’interface graphique
		self.__ui = Ui_MainWindow()
		# Affectation de l’interface à notre fenêtre principale
		self.__ui.setupUi(self)

		# déclaration de l’automate
		tempPLC = ModbusPLC("127.0.0.1","Test 0",self.initVarList())
		self.__plcClientList = [tempPLC]
		#index de l'automate actuellement sélectionné
		self.__plcSelected = 0

		#ajout d'un deuxième automate
		tempPLC = ModbusPLC("127.0.0.1","Test 1",self.initVarList())
		self.__plcClientList.append(tempPLC)
\end{Python}

Il ne nous reste plus qu'à compléter la fonction d'affectation des variables de l'automate.\footnote{\colors{red}{Ou presque !} Il faudra ensuite "lancer" l'automate mais ceci sera abordé dans la section "Gestion pseudo-événementielle"}


\subsection{Déclaration d'une variable}

Voici le prototype du constructeur du type \ib{PLCVar}\footnote{Pour plus d'informations sur ce type et son constructeur, se référer à la documentation} :
\begin{Python}
PLCVar(name,address,description,varType,varMode,f_connectedSlots = []):
\end{Python}
Pour un descriptif rapide des paramètres :
\begin{enumerate}
\item \bold{name} : C'est le nom de la variable, chaque nom doit être unique, on préférera éviter les caractères spéciaux et les espaces.

\item \bold{address} : C'est l'index de l'adresse dans l'automate. Par exemple 1 pour \%M1 ou \%MW1 (nous verrons après que l'adresse est aussi déterminée par le type de la variable). Ce paramètre attend un \bold{entier}.

\item \bold{description} : Il s'agit d'une description de la variable.

\item \bold{varType} : il s'agit du type de la variable aux yeux de l'automate. On ne peut pas utiliser n'importe quel type, pour le moment, seuls sont supportés : 

\begin{enumerate}
    \item "BIT"
    \item "WORD"
    \item "DWORD"
    \item "TIME"
    \item "INT"
\end{enumerate}

Ce type est très important, c'est lui qui va fixer les fonctions à utiliser pour communiquer avec l'automate et qui servira à convertir les données si besoin est.

\item \bold{varMode} : Il s'agit du mode de fonctionnement de la variable soit \ib{INPUT} ou \ib{OUTPUT}

\item \bold{f\_connectedSlots} : Il s'agit d'une liste de fonction à appeler lorsqu'un changement de valeur est détecté avec une \ib{EventsLoop} (nous verrons cela un peu plus tard). Cet argument est optionnel.
\end{enumerate}


Maintenant que nous savons ce qu'il faut fournir pour déclarer une variable de ce type, nous n'avons plus qu'à le faire. Nous allons aborder deux exemples qui donneront une idée de ce qu'il est possible de faire.

\begin{enumerate}


\item \bold{Variable "\italic{BIT}"}\newline
Nous allons ici déclarer une variable de type "\italic{BIT}" à l'adresse "\italic{\%M5}" qui représentera l'état d'un bouton "\italic{dcy}" qui fonctionnera donc comme une entrée.\newline
La déclaration de cette variable directement dans la liste liste \bold{varList} se fera de la manière suivante :
\begin{Python}
varList.append(PLCVar("dcy",5,"Bouton permettant de lancer un cycle","BIT","INPUT"))
\end{Python}

\item \bold{Variable "\italic{WORD}"}\newline
Puis une variable de type "\italic{WORD}" à l'adresse "\italic{\%MW0}" qui représentera la nouvelle valeur d'un compteur ("\italic{new\_cycle\_count}") qui fonctionnera donc comme une sortie.\newline
La déclaration de cette variable directement dans la liste liste \bold{varList} se fera de la manière suivante :
\begin{Python}
varList.append(PLCVar("new_cycle_count",0,"Nouveau nombre de cycle à exécuter","WORD","OUTPUT"))
\end{Python}

\end{enumerate}

Nous rajouterons une troisième variable, elle aussi de type "BIT" pour pouvoir exposer un autre élément du code un peu plus tard.

Le code de votre fonction d'initialisation devrait donc maintenant ressembler à ceci :
\begin{Python}
    def __init__(self, parent=None):
    
        #code constructeur...
        
    def initVarList(self):
	    varList = [] #initialisation de la liste de variables

    	#déclarations des différentes variables
	    varList.append(PLCVar("dcy",5,"Bouton permettant de lancer un cycle","BIT","INPUT"))

    	varList.append(PLCVar("new_cycle_count",0,"Nouveau nombre de cycle à exécuter","WORD","OUTPUT"))
    	
    	varList.append(PLCVar("alarmButton", 6, "Bouton d'alarme","BIT","INPUT"))

	    return varList  #on retourne la liste de variables
\end{Python}





\subsection{Affichage d'une variable dans le terminal}

Lors du débogage par exemple, vous pourriez avoir besoin d'afficher dans la console une variable. Nous allons voir comment afficher une variable présente dans une liste dans un terminal.\newline
Nous utiliserons le même code, donc les mêmes variables que dans les exemples ci-dessus.\newline
Le code que nous allons écrire\footnote{A l'exception de l'importation des modules bien entendu} prendra place dans le constructeur du type "\ib{MainWindow}", après l'initialisation de la liste de variables et de l'automate (cette ligne là : )
\begin{Python}
# déclaration de l’automate
self.__plcClientList = [ModbusPLC("127.0.0.1","Automate Test 0",self.initVarList())]
\end{Python}


Imaginons que nous souhaitions afficher la variable "\italic{dcy}". Deux solutions s'offrent à nous pour trouver cette variable dans la liste:
\begin{enumerate}
\item Vous vous souvenez de l'index de la variable et vous pouvez écrire cet index "en dur", directement dans le code. Cette solution n'est pas la meilleure, en effet, si pour une raison quelconque l'index de la variable change, le résultat obtenu ne sera plus celui attendu.

\item Vous utilisez une fonction fournie dans le module \\ "\ib{ENIBSupervision.PLC.Variable}" qu'il vous faudra donc \bold{importer}, en utilisant par exemple :
\begin{Python}
import ENIBSupervision.PLC.Variable as PLCVariable
\end{Python}
Et la fonction qui nous intéresse est "\ib{findVariableInList}" qui permet de retourner l'index de la variable recherchée dans une liste. Voici son prototype :
\begin{Python}
def findVariableInList(varList,varName):
\end{Python}
Cette fonction retourne l'index de la variable ou -1 si celle-ci n'a pas été trouvée.
\end{enumerate}


Nous préférerons ici utiliser la deuxième solution. Pour afficher la variable "\italic{dcy}", nous devons donc en premier lieu récupérer son index dans notre liste. Vous avez tous les éléments pour effectuer cette tâche, cette opération se traduit par exemple par ceci :
\begin{Python}
tmp_varList = self.initVarList()
#self.initVarList retourne la liste des variables de l'automate
dcyIndex = PLCVariable.findVariableInList(tmp_varList,"dcy")
\end{Python}
Une fois que nous avons son index, nous pouvons nous en servir pour afficher la variable dans le terminal :
\begin{Python}
print(str(tmp_varList[dcyIndex]))
\end{Python}
Explications :\newline
La fonction "\italic{print()}" permet d'afficher quelque chose dans le terminal.\newline
La fonction "\italic{str()}" permet de convertir un élément en chaîne de caractère.\newline
Et "\italic{tmp\_varList[dcyIndex]}" permet d'accéder à l'élément de la liste "\italic{tmp\_varList}" à l'index "\italic{dcyIndex}".\\





%%%%% HALTE
%%%%% Nico



Voici maintenant à quoi devrait ressembler le constructeur de votre type "\ib{MainWindow}" :
\begin{Python}

	# déclaration du constructeur avec un possible parent
	def __init__(self, parent=None):
        # on appelle le constructeur de la class parent
        super().__init__(parent)

        # initialisation de l’interface graphique
        self.__ui = Ui_MainWindow()
        # Affectation de l’interface à notre fenêtre principale
        self.__ui.setupUi(self)

        # déclaration de l’automate
        tempPLC = ModbusPLC("127.0.0.1","Test 0",self.initVarList())
        self.__plcClientList = [tempPLC]    
		#index de l'automate actuellement sélectionné
        self.__plcSelected = 0
        #lancement de l'automate sélectionné
        self.__plcClientList[self.__plcSelected].start()

        #ajout d'un deuxième automate
        tempPLC = ModbusPLC("127.0.0.1","Test 1",self.initVarList())
        self.__plcClientList.append(tempPLC)

        # récupération de l’index de la variable "dcy"
        tmp_varList = self.initVarList()
        #self.initVarList() retourne la liste des variables de l'automate
        dcyIndex = PLCVariable.findVariableInList(tmp_varList,"dcy")
        print(str(self.__plcClientList[self.__plcSelected].varList()[dcyIndex]))

\end{Python}


Vous n'avez maintenant plus qu'à lancer le programme
et vous devriez voir s'afficher un résultat de ce type :
\img{\rootImages/enibSup_result_printPLCVar.png}{Résultat du programme dans un terminal}{0.4}




\section{Gestion pseudo-événementielle}

Nous avons plusieurs solutions entre : 
\begin{enumerate}
\item Rédiger manuellement toutes les interactions avec l'automate : lecture et écriture des variables
\item Utiliser le type \ib{EventsLoop} du module \lib{ENIBSupervision} qui fera (presque) tout à votre place.
\end{enumerate}
Vous imaginez bien que nous préférerons ici la deuxième solution.\\
Nous avons décidés d'automatiser la communication des variables au sein du module 
\lib{ModbusPLC} afin de simplifier la gestion de ces dernières. \\
Si vous préférez la première, les outils de ce module ne fonctionneront pas ou mal.\\

Lors de la création d'un automate avec l'instruction suivante :
\begin{Python}
ModbusPLC("127.0.0.1","Automate Test 0",self.initVarList())
\end{Python}
Une boucle d'évènement est associée et permet d'appeler des fonctions lors de changements d'états des variables. \\
Cette boucle d'événement correspond au type \ib{EventsLoop} du module \lib{ENIBSupervision}. Elle existe mais l'utilisateur n'a normalement pas à intéragir directement avec elle. C'est pour cela que nous n'aborderons pas son fonctionnement exact ici.\\

Cependant, pour économiser de la puissance de calcul, lorsque l'automate est instancié, la boucle d'événements est par défaut "stoppée". Il faut donc la lancer pour que celle-ci puisse fonctionner. Cela se fait par le biais de la commande :
\begin{Python}
	#lancement de l'automate sélectionné
	self.__plcClientList[self.__plcSelected].start()
\end{Python}

\colors{red}{Si vous oubliez cette étape, votre programme risque de ne pas fonctionner} (c'est même le cas le plus probable)


Si vous exécutez le programme sans que l'automate ne soit accessible, vous devriez voir plusieurs messages d'erreurs apparaître comme ici :

\img{\rootImages/enibSup_error_cannotConnectToPLC.png}{Messages d'erreurs typiques}{0.3}

Ceux-ci ne font que prévenir l'utilisateur qu'il est impossible de se connecter à l'automate pendant l'écriture/la lecture d'une variable tout en précisant celle-ci.


Maintenant que nous avons mis en place les outils essentiels pour le bon fonctionnement de la suite, nous allons aborder les outils plus avancés mis à la disposition des utilisateurs du module \lib{ENIBSupervision}.\\

Mais avant ça, voici un petit rappel de ce à quoi votre fichier \\
\file{UI\_MainWindow.py} devrait ressembler au complet : %COMPLETE_FILE
\begin{Python}

# -*- coding : utf-8 -*-
# on explicite l’ encodage du fichier

# importation des modules nécessaires à Qt
from PyQt5 import QtCore, QtGui, QtWidgets

import time

# importation du module nécessaire à la création de notre fenêtre principale
from UI_pyFiles.MainWindow import Ui_MainWindow

# importation des modules de supervision
from ENIBSupervision.PLC.Variable import PLCVar
import ENIBSupervision.PLC.Variable as PLCVariable
import ENIBSupervision.EventsLoop as EventsLoop
from ENIBSupervision.UI_class.UI_AnimationTables import AnimationTables
from ENIBSupervision.PLC.ModbusPLC import ModbusPLC

import ENIBSupervision.PLC.Communication as Com


class MainWindow (QtWidgets . QMainWindow):  # déclaration de la class MainWindow

	# déclaration du constructeur avec un possible parent
	def __init__(self, parent=None):
        # on appelle le constructeur de la class parent
        super().__init__(parent)

        # initialisation de l’interface graphique
        self.__ui = Ui_MainWindow()
        # Affectation de l’interface à notre fenêtre principale
        self.__ui.setupUi(self)

        # déclaration de l’automate
        tempPLC = ModbusPLC("127.0.0.1","Test 0",self.initVarList())
        self.__plcClientList = [tempPLC]    
		#index de l'automate actuellement sélectionné
        self.__plcSelected = 0
        #lancement de l'automate sélectionné
        self.__plcClientList[self.__plcSelected].start()

        #ajout d'un deuxième automate
        tempPLC = ModbusPLC("127.0.0.1","Test 1",self.initVarList())
        self.__plcClientList.append(tempPLC)
        
       
		#lancement de l'automate sélectionné
		self.__plcClientList[self.__plcSelected].start()

        # récupération de l’index de la variable "dcy"
        tmp_varList = self.initVarList()
        #self.initVarList() retourne la liste des variables de l'automate
        dcyIndex = PLCVariable.findVariableInList(tmp_varList,"dcy")
        print(str(self.__plcClientList[self.__plcSelected].varList()[dcyIndex]))


    def initVarList(self):
	    varList = [] #initialisation de la liste de variables

        #déclarations des différentes variables
	    varList.append(PLCVar("dcy",5,"Bouton permettant de lancer un cycle","BIT","INPUT",self.dcyStateChanged))
        #On relie la variable à la méthode "dcyStateChanged" de MainWindow (dernier argument passé)

    	varList.append(PLCVar("new_cycle_count",0,"Nouveau nombre de cycle à exécuter","WORD","OUTPUT"))

        varList.append(PLCVar("alarmButton", 6, "Bouton d'alarme","BIT","INPUT", self.checkAlarm)) #ajout de la variable

	    return varList  #on retourne la liste de variables

\end{Python}



\section{Connexion d'une fonction à une variable}

Le module \lib{ENIBSupervision} permet d'associer une fonction à un changement d'état d'une variable
\footnote{Il est possible d'associer \bold{plusieurs fonctions} au changement d'état d'\bold{une} variable.}
.\newline

Nous verrons deux possibilités pour associer un changement d'état de variable à une fonction.\newline
\begin{enumerate}
    \item \bold{Association à l'instanciation}\newline Cette méthode, la plus simple, permet d'associer une fonction au changement d'état de la variable lors de la déclaration de celle-ci
    
    \item \bold{Indépendante}\newline Cette méthode, la plus générique, permet d'associer une fonction au changement d'état de la variable n'importe quand dans le programme.
\end{enumerate}


Pour la deuxième possibilité, nous allons donc créer une variable d'entrée "alarmButton" avec l'adresse 6, de type "BIT" et de désignation "Bouton d'alarme". \newline Cette variable sera crée dans la fonction initVarList et ajoutée à l'automate. \newline
\begin{Python}
    #... autres variables déja crées
    
    varList.append(PLCVar("alarmButton", 6, "Bouton d'alarme","BIT","INPUT", self.checkAlarm))
    
    return varList
\end{Python}

\subsection{Généralités}

Les fonctions associées au changement d'état d'une variable doivent recevoir un paramètre, celui-ci correspond à la variable modifiée.
Dans le cas d'une fonction non-membre, le prototype ressemblera à ceci :
\begin{Python}
def function(var):
\end{Python}
Et dans le cas d'une fonction membre :
\begin{Python}
def function(self,var):
\end{Python}

\subsection{Association à l'instanciation}

L'association à l'instanciation se fait extrêmement simplement en passant en dernier paramètre le nom de la fonction à associer.\newline
Pour l'exemple, nous allons tout d'abord créer une fonction à associer au changement d'état de la variable "dcy". Celle-ci ne fera qu'afficher un message avec la valeur de la variable dans la console mais elle sera une fonction membre de la classe \ib{MainWindow} pour se rapprocher d'un cas d'utilisation réél (impactant l'interface).\newline
Sa définition sera donc :
\begin{Python}
def dcyStateChanged(self,var):
		print("dcy state has changed : "+str(var.getVarValue()))
\end{Python}

Pour associer cette fonction au changement d'état de la variable dcy, il nous faut maintenant modifier la déclaration de celle-ci comme expliqué plus haut, ce qui se résume à \footnote{Dans la fonction \italic{initVarList}} :
\begin{Python}
#déclarations des différentes variables
varList.append(PLCVar("dcy",50,"Bouton permettant de lancer un cycle","BIT","INPUT",self.dcyStateChanged))
#On relie la variable à la méthode "dcyStateChanged" de MainWindow (dernier argument passé)
\end{Python}
 Et voilà ! Maintenant, dès que l'état de la variable "dcy" sera modifié dans l'automate, cette fonction sera appelée et affichera dans le terminal la valeur de "dcy".
 
 \subsection{Association "Indépendante"}
 
 Cette méthode permet d'associer le changement d'état d'une variable à une fonction n'importe où dans le programme.
\newline
Cette méthode est strictement identique à l'usage que l'on a des signaux et slots Qt. Ce qui est normal puisque ce sont des signaux Qt qui sont utilisés.

\colors{red}{\bold{Tous les signaux créés spécialement pour le module}} \lib{ENIBSupervision} \colors{red}{\bold{commencent par le préfixe "sig\_"}}


Pour cet exemple, nous allons associer notre nouvelle variable "alarmButton" à une fonction qui affiche son état.\newline
Il faut donc commencer par définir cette fonction (elle est aussi membre de \ib{MainWindow}) :
\begin{Python}
def checkAlarm(self,var):
		#alarme
		print("checking alarm")
\end{Python}

Puis il faut ensuite associer le changement d'état de notre variable à notre fonction. Cette fois, nous ne changerons pas la déclaration mais rajouterons une instruction pour les connecter.\newline
Cette instruction prendra place juste après sa déclaration et nous utiliserons le signal de \ib{PLCVar} : \italic{sig\_valueChanged} :
\begin{Python}
#On relie la variable à la méthode "checkAlarm" de MainWindow
varList[-1].sig_valueChanged.connect(self.checkAlarm)
\end{Python}
Cette instruction ne fait rien d'autre que relier le signal \italic{sig\_valueChanged} du dernier élément de la liste \bold{varList} à la fonction \italic{self.checkAlarm}.\newline
D'où l'importance de la placer juste après la déclaration de la variable "alarmButton", ce qui devrait vous donner au final pour la fonction \italic{initVarList} :

\begin{Python}
def initVarList(self):
	varList = []  #initialisation de la liste de variables


	#déclarations des différentes variables
	varList.append(PLCVar("dcy",50,"Bouton permettant de lancer un cycle","BIT","INPUT",self.dcyStateChanged))
	#On relie la variable à la méthode "dcyStateChanged" de MainWindow (dernier argument passé)

	varList.append(PLCVar("new_cycle_count",0,"Nouveau nombre de cycle à exécuter","WORD","OUTPUT"))

	varList.append(PLCVar("alarmButton", 51, "Bouton d'alarme","BIT","INPUT")) #ajout de la variable
	#On relie la variable à la méthode "checkAlarm" de MainWindow
	varList[-1].sig_valueChanged.connect(self.checkAlarm)

	return varList  # on retourne la liste de variables
\end{Python}


\section{Tables d'animations}

Nous arrivons maintenant dans les outils graphiques proposés par le module \lib{ENIBSupervision}.\newline
Nous allons voir dans cette section comment créer facilement et rapidement des tables d'animations utilisables.\newline
Ces tables d'animations se présentent sous la forme d'une fenêtre dockable.\\

La création de ces tables se fait en deux lignes. Il suffit de les déclarer et les affichers.\newline
Cependant, nous en avons maintenant l'habitude, il nous faut tout d'abord importer le type (\ib{AnimationTables}) nécessaire depuis le module adapté, le module \lib{ENIBSupervision.UI\_class.UI\_AnimationTables}, cela se traduit par :
\begin{Python}
from ENIBSupervision.UI_class.UI_AnimationTables import AnimationTables
\end{Python}


Voici le prototype du type \ib{AnimationTables} :
\begin{Python}
AnimationTables(plcVarList,parent = None,qdockWidgetArea = QtCore.Qt.RightDockWidgetArea)
\end{Python}
Et une description rapide des arguments :
\begin{enumerate}
    \item \bold{plcVarList} : Il s'agit d'une liste de variables de type "\ib{PLCVar}"
    \item \bold{parent} : Il s'agit du widget Qt parent de nos tables d'animations. Souvenez-vous, je vous avais dit qu'il était d'usage de fournir à un widget Qt un parent. Ici, \ib{AnimationTables} est un type pour lequel ce parent est important pour profiter de toutes les possibilités offertes.
    \item \bold{qdockWidgetArea} : il s'agit de la zone dans laquelle les tables d'animations seront dockées par défaut. C'est un paramètre un peu particulier, voici quelques exemples de valeurs acceptées :
    \begin{enumerate}
        \item \italic{QtCore.Qt.RightDockWidgetArea}
        \item \italic{QtCore.Qt.LeftDockWidgetArea}
        \item \italic{QtCore.Qt.BottomDockWidgetArea}
        \item \italic{QtCore.Qt.TopDockWidgetArea}
    \end{enumerate}
\end{enumerate}


Maintenant que nous voyons à peu près comment initialiser les tables d'animations, voici comment l'on pourrait faire en pratique :
\begin{Python}
self.__animTables = AnimationTables(self.__plcClientList[self.__plcSelected].varList(), self)
\end{Python}
\bold{Nous allons placer cette instruction à la fin du constructeur de classe}.
Si l'on analyse rapidement cette déclaration, on constate que nous ne faisons que initialiser une variable \bold{self.\_\_animTables} avec comme liste de variables \\ \italic{self.\_\_plcClientList[self.\_\_plcSelected].varList()} [en choisissant l'index de l'automate] et comme parent, notre \ib{MainWindow}.\newline
Notez que c'est à nouveau une variable membre de notre class \ib{MainWindow} car encore une fois, nous pourrions en avoir besoin dans d'autres fonctions.\\

Nous avons déclaré nos tables, nous n'avons plus qu'à les afficher, ce qui se fera à l'aide de la fonction membre \italic{.show()} (toujours à la fin du constructeur).
En mettant ce code dans le constructeur, nous instancions et affichons les tables d'animation.
\begin{Python}

def __init___(self, parent=None):

    #code précédent ...
    
    self.__animTables = AnimationTables(self.__plcClientList[self.__plcSelected].varList(), self)
    self.__animTables.show() #on les affiche
    
def initVarList(self):
    #...
\end{Python}



Vous devriez maintenant avoir des tables d'animations que vous pouvez "détacher" de la fenêtre principale, manipuler normalement. Je vous laisse explorer les possibilités.\newline
Voici le type de résultat que vous devriez obtenir :
\img{\rootImages/enibSup_window_animationTables.png}{Tables d'animations dans\protect\\la fenêtre principale}{0.4}


\subsection{Ouvrir les tables d'animations}

Il est possible de créer un bouton et de demander qu'à chaque appui, il ouvre les tables d'animations.

Pour cela, rien de plus simple :

\begin{enumerate}
    \item On créer un bouton avec QtDesigner que l'on appelle "start\_tableAnimat"
    \item On crée une fonction membre appelée \italic{showTables} qui, à chaque appel, se contentera d'ouvrir et d'afficher les tables d'animations de l'automate.
    
    \begin{Python}
        def initVarList(self):
        
            #...
        
        def showTables(self):
            #Ouverture des tables d'animations
            self.__animTables.show()
    \end{Python}
    \item On relie le signal du bouton à la fonction membre \italic{showTables()} \bold{dans le constructeur}' \footnote{En cas d'oubli de méthode, le rappel est au chapitre 8.6}
    
    \begin{Python}
        self.__ui.start_tableAnimat.clicked.connect(self.showTables)
    \end{Python}
   
\end{enumerate}

Et voila, à chaque appui sur le bouton, lorsque les tables d'animations seront fermées, elles s'ouvriront.

\subsection{Modifier l'état d'une variable de l'automate}

Nous allons maintenant voir comment modifier l'état d'une variable dans l'automate.\newline
Nous allons tout d'abord rechercher la variable qui nous intéresse puis modifier son état.

Pour l'exemple, nous modifierons la variable "new\_cycle\_count" de l'automate actuellement sélectionné.\newline
Nous ferons en sorte que lorsque nous appuyons sur le bouton "start" de l'interface graphique, cette variable soit incrémentée mais tout en maintenant sa valeur dans l'intervalle [0;10[ : lorsque la valeur de la variable atteint 9, elle vaudra 0 la prochaine fois.\newline
Pour cela nous allons créer une nouvelle fonction qu'il nous faudra \bold{connecter à l'appui sur le bouton "start"} : \italic{incrementNewCycleCount} qui exécutera l'action que nous avons expliqués plus haut.\\
Voici le code au complet détaillé de la fonction permettant cette action :

\begin{Python}
def incrementNewCycleCount(self):
	#on accède à la liste de variables visée : celle de l'automate sélectionné
	tempVarList = self.__plcClientList[self.__plcSelected].varList()

	#on récupère l'index de la variable dans cette liste
	varIndex = PLCVariable.findVariableInList(tempVarList,"new_cycle_count")

	#on calcule la nouvelle valeur
	newVal = (tempVarList[varIndex].getVarValue()+1)%10

	#on affecte la nouvelle valeur à la variable automate
	tempVarList[varIndex].setVarValue(newVal)
\end{Python}
Le code ci-dessus contient le détail de toutes les opérations nécessaires.\newline
Notez que l'affectation en elle-même ne se fait qu'en une seule ligne.\\

Encore une fois, n'oubliez pas de connecter cette fonction au click du bouton (par cohérence, nous ne pouvons que vous inviter à placer cette connexion juste après celle déjà existante) ce qui devrait vous donner :
\begin{Python}
self.__ui.pb_start.clicked.connect(self.showAnimTables)
self.__ui.pb_start.clicked.connect(self.incrementNewCycleCount)
\end{Python}


Et voilà ! Si vous lancez le programme, vous devriez constater que à chaque clic sur le bouton, cette variable s'incrémentera au niveau de l'automate.

\chapter{Code de l'exemple au complet}


\newpage
\section{main.py}

\begin{Python}

# -*- coding : utf-8 -*-
#on explicite l’ encodage du fichier

# importation des modules né cessaires à Qt
import sys
from PyQt5 import QtCore , QtGui , QtWidgets

# importation du module d’interface graphique créé
from UI_class.UI_MainWindow import MainWindow

from ENIBSupervision.Utils import Debug as EDebug
from ENIBSupervision.PLC import ModbusPLC


def main():
	app = QtWidgets.QApplication (sys.argv)

	mainWindow = MainWindow ()
	mainWindow.show ()

	#exécution de l’application Qt
	sys.exit(app.exec())

#si c’est ce module qui est lancé directement
if( __name__ == "__main__") :
	
	main()

	client = ModbusPLC.ModbusPLC("127.0.0.1","Auto")
	client.connect()
	EDebug.debuggingTool(client)


\end{Python}

\newpage
\section{UI\_class/UI\_MainWindow.py}

\begin{Python}

# -*- coding : utf-8 -*-
# on explicite l’ encodage du fichier

# importation des modules nécessaires à Qt
from PyQt5 import QtCore, QtGui, QtWidgets

import time

# importation du module nécessaire à la création de notre fenêtre principale
from UI_pyFiles.MainWindow import Ui_MainWindow

# importation des modules de supervision
from ENIBSupervision.PLC.Variable import PLCVar
import ENIBSupervision.PLC.Variable as PLCVariable
import ENIBSupervision.EventsLoop as EventsLoop
from ENIBSupervision.UI_class.UI_AnimationTables import AnimationTables
from ENIBSupervision.PLC.ModbusPLC import ModbusPLC

import ENIBSupervision.PLC.Communication as Com


class MainWindow (QtWidgets . QMainWindow):  # déclaration de la class MainWindow

	# déclaration du constructeur avec un possible parent
	def __init__(self, parent=None):
		# on appelle le constructeur de la class parent
		super().__init__(parent)

		# initialisation de l’interface graphique
		self.__ui = Ui_MainWindow()
		# Affectation de l’interface à notre fenêtre principale
		self.__ui.setupUi(self)

		# déclaration de l’automate
		self.__plcClientList = [ModbusPLC("127.0.0.1","Automate Test 0",self.initVarList())]
		#index de l'automate actuellement sélectionné
		self.__plcSelected = 0
		#lancement de l'automate sélectionné
		self.__plcClientList[self.__plcSelected].start()

		#ajout d'un deuxième automate
		self.__plcClientList.append(ModbusPLC("127.0.0.1","Automate Test 1",self.initVarList(),"Description automate 1"))


		#lancement de l'automate sélectionné
		self.__plcClientList[self.__plcSelected].start()

		# récupération de l’index de la variable "dcy"
		#dcyIndex = PLCVariable.findVariableInList(self.__plcClientList[self.__plcSelected].varList(), "dcy")
		# affichage de la variable
		#print(str(self.__plcClientList[self.__plcSelected].varList()[dcyIndex]))

		#déclaration des tables d’animations
		self.__animTables = AnimationTables(self.__plcClientList[self.__plcSelected].varList(), self)
		#self.__animTables.show()  # on les affiche

		self.__ui.pb_start.clicked.connect(self.showAnimTables)
		self.__ui.pb_start.clicked.connect(self.incrementNewCycleCount)

	
	#SLOTS UI
	def checkAlarm(self,var):
		#alarme
		print("checking alarm : "+str(var.getVarValue()))
	
	def dcyStateChanged(self,var):
		print("dcy state has changed : "+str(var.getVarValue()))

	def showAnimTables(self):
		self.__animTables.show()
	
	def incrementNewCycleCount(self):
		#on accède à la liste de variables visée : celle de l'automate sélectionné
		tempVarList = self.__plcClientList[self.__plcSelected].varList()

		#on récupère l'index de la variable dans cette liste
		varIndex = PLCVariable.findVariableInList(tempVarList,"new_cycle_count")

		#on calcule la nouvelle valeur
		newVal = (tempVarList[varIndex].getVarValue()+1)%10

		#on affecte la nouvelle valeur à la variable automate
		tempVarList[varIndex].setVarValue(newVal)

	def initVarList(self):
		varList = []  #initialisation de la liste de variables


		#déclarations des différentes variables
		varList.append(PLCVar("dcy",50,"Bouton permettant de lancer un cycle","BIT","INPUT",self.dcyStateChanged))
		#On relie la variable à la méthode "dcyStateChanged" de MainWindow (dernier argument passé)

		varList.append(PLCVar("new_cycle_count",0,"Nouveau nombre de cycle à exécuter","WORD","OUTPUT"))

		varList.append(PLCVar("alarmButton", 51, "Bouton d'alarme","BIT","INPUT")) #ajout de la variable
 		#On relie la variable à la méthode "checkAlarm" de MainWindow
		varList[-1].sig_valueChanged.connect(self.checkAlarm)

		return varList  # on retourne la liste de variables


def incrementNewCycleCount(self):
	#on accède à la liste de variables visée : celle de l'automate sélectionné
	tempVarList = self.__plcClientList[self.__plcSelected].varList()

	#on récupère l'index de la variable dans cette liste
	varIndex = PLCVariable.findVariableInList(tempVarList,"new_cycle_count")

	#on calcule la nouvelle valeur
	newVal = (tempVarList[varIndex].getVarValue()+1)%10

	#on affecte la nouvelle valeur à la variable automate
	tempVarList[varIndex].setVarValue(newVal)
		
\end{Python}