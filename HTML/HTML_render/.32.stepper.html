<html><head><style>.cent {  display: block;  margin-left: auto;  margin-right: auto;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script><body style='margin-left:5%;margin-right:5%;margin-top:1%'><h4>Fichier générer depuis les sources Latex</h4><h5>Auteur : Nicolas Le Guerroué</h5><a href='index.html'><button class='btn btn-success' >Revenir au sommaire</button></a><hr> 

<h2 >Présentation</h2>
\newcommand{\pap}{moteur pas-à-pas~}  
\newcommand{\paps}{moteurs pas-à-pas~}

Les \pap sont utilisés lorsqu'on souhaite un asservissement en position d'un axe de rotation avec une précision inégalée par 

les servomoteurs.

 
<h4>Constitution</h4>
Les \pap sont constitués de :

<ul>
<li> Plusieurs bobines (un pôle forme une paire de bobines)
</li>
<li> Un aimant qui sert d'axe de rotation
</li>
</ul>
<h4>Les types de \pap</h4>
<ul>
  <li> \pap à phase bipolaire
</li>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/moteur_bipolaire.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/moteur_bipolaire.png' class='alignnone size-medium' style='max-width:40%;'></a><figcaption>Figure - \pap bipolaire</figcaption></div></figure>
  <li> \pap à phases unipolaires
</li>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/step_wire.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/step_wire.png' class='alignnone size-medium' style='max-width:40%;'></a><figcaption>Figure - \pap unipolaires</figcaption></div></figure>
  <li> \pap à reluctance variable (non abordés ici)
</li>
</ul>
<h4>Principe</h4>
En faisant varier le champ électromagnétique des différentes phases, on peut faire varier la position angulaire de l'aimant.

<h4>Exemples avec phases bipolaires</h4>
En alimentant une paire de phases avec une tension positif, l'aimant se place dans l'alignement du champ électromagnétique 

formé par la paire de phase.

En alimentant la paire de phase avec une tension négative, l'aimant se place dans le sens contraire.

<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/step1.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/step1.png' class='alignnone size-medium' style='max-width:30%;'></a><figcaption>Figure - Pas 1</figcaption></div></figure>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/step2.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/step2.png' class='alignnone size-medium' style='max-width:30%;'></a><figcaption>Figure - Pas 2</figcaption></div></figure>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/step3.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/step3.png' class='alignnone size-medium' style='max-width:30%;'></a><figcaption>Figure - Pas 3</figcaption></div></figure>
<h4>Exemples avec phases unipolaires</h4>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/ste2.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/ste2.png' class='alignnone size-medium' style='max-width:30%;'></a><figcaption>Figure - Pas 1</figcaption></div></figure>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/ste21.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/ste21.png' class='alignnone size-medium' style='max-width:30%;'></a><figcaption>Figure - Pas 2</figcaption></div></figure>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/ste22.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/ste22.png' class='alignnone size-medium' style='max-width:30%;'></a><figcaption>Figure - Pas 3</figcaption></div></figure>
Les moteurs possèdent plus de phases car un débattement de 45° est vite limité.

<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/inside.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/inside.png' class='alignnone size-medium' style='max-width:100%;'></a><figcaption>Figure - Un intérieur de moteur</figcaption></div></figure>
Les \pap unipolaires présentent l'avantage de faire circuler un courant positif dans le circuit de commande. 

Ils sont donc plus simples à mettre en oeuvre mais ils nécessitent plus de bobinage.

<h2 >Commande des \paps</h2>
<h3>Moteurs unipolaires</h3>
Les \pap unipolaires ont besoins d'être contrôlés via un circuit adaptés, le plus connu est le <span style='background-color:blue;opacity:60%;color:white;' class='badge badge-pill'>ULN2803</span>

<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/udn.jpg'><img src='http://www.crepp.org/wp-content/uploads/2022/08/udn.jpg' class='alignnone size-medium' style='max-width:60%;'></a><figcaption>Figure - Driver ULN2803</figcaption></div></figure>
Pour les moteurs unipolaires, il faut mettre une des phases à la masse pour faire circuler le courant dans la phase <span title="Due au cable relié à l'alimentation positive du moteur" style='color:grey;'><sup>[note]</sup></span>

On constate sur la figure suivante un montage Darlington : deux transistors NPN forme un seul transistor dont le coefficient

\(\(\beta\)\) est le produit de chacun des coefficients \(\(\beta\)\) de chaque transistor.

Cela permet de contrôler des charges avec très peu de courant de commande. <span title="Se référer à la partie \bold{Circuits de puissance" style='color:grey;'><sup>[note]</sup></span>}

<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/darlington.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/darlington.png' class='alignnone size-medium' style='max-width:60%;'></a><figcaption>Figure - Contrôle d'une phase</figcaption></div></figure>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/uln_pinout.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/uln_pinout.png' class='alignnone size-medium' style='max-width:60%;'></a><figcaption>Figure - Driver de controle</figcaption></div></figure>
<h3>Moteurs bipolaires</h3>
On a vu qu'il fallait inverser la tension de commande au borne des bobines. Pour cela on peut utiliser le montage en pont en H.

<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/pont.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/pont.png' class='alignnone size-medium' style='max-width:50%;'></a><figcaption>Figure - Structure du pont en H</figcaption></div></figure>
<ul>
  <li> En activant S1 et S4 (fermeture du circuit), la charge est parcourue par un courant allant de gauche à droite
</li>
  <li> En activant S2 et S3 (fermeture du circuit), la charge est parcourue par un courant allant de droite à gauche
</li>
</ul>
Et qui dit inversion de courant dit inversion de tension. Notre objectif est atteint, nous pouvons mettre des tensions positives 

et négatives aux bornes des phases de nos moteurs.

Ce principe est également utilisé pour contrôler les moteurs à courant continu

On peut utiliser le circuit <span style='background-color:blue;opacity:60%;color:white;' class='badge badge-pill'>L298</span>

<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/l298.jpg'><img src='http://www.crepp.org/wp-content/uploads/2022/08/l298.jpg' class='alignnone size-medium' style='max-width:30%;'></a><figcaption>Figure - Un pont en H intégré</figcaption></div></figure>
<h4>Avantages et inconvénients des \paps</h4>
<ul>
    <li> Très grande précision en boucle ouverte <span title="Contrôle sans asservissement, contrairement aux servomoteurs" style='color:grey;'><sup>[note]</sup></span>
</li>
    <li> Couple élevé en bas régime
</li>
</ul>
<ul>
  <li> Plus lent qu'un servomoteur
</li>
  <li> Complexité de mise en oeuvre
</li>
</ul>
<h4>Domaines d'application</h4>
<ul>
    <li> Imprimantes
</li>
    <li> Machines CNC
</li>
</ul>
<h3>Comment distinguer les différents types de moteurs ?</h3>
<ul>
  <li> 2 fils = moteur à courant continue
</li>
  <li> 3 fils = servomoteurs
</li>
  <li> 4 fils = \pap bipolaire
</li>
  <li> 5 fils = \pap unipolaire
</li>
</ul>
<h2 >Exemples</h2>
<h3>Mise en pratique avec Arduino</h3> 
Nous utiliserons un \pap <b>28BYJ-48</b> de type unipolaire. 
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/byj.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/byj.png' class='alignnone size-medium' style='max-width:30%;'></a><figcaption>Figure - Le moteur 28BYJ-48 </figcaption></div></figure>
Les caractéristiques sont les suivantes : 

<ul>
  <li> Nombre de pas : 2048
</li>
  <li> Tension d'alimentation : 5V
</li>
</ul>
Pour augmenter le nombre de pas, on ajoute un train d'engrenage.

<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/reduce.jpg'><img src='http://www.crepp.org/wp-content/uploads/2022/08/reduce.jpg' class='alignnone size-medium' style='max-width:80%;'></a><figcaption>Figure - Une augmentation du nombre de pas</figcaption></div></figure>
<h4>Liste du matériel</h4>
<ul>
  <li> Carte Arduino Uno
</li>
  <li> Driver ULN2803
</li>
  <li> Moteur \pap 28BYJ-48 ou équivalent
</li>
  <li> Câbles
</li>
</ul>
<h4>Branchements</h4>
Nous utiliserons les broches 8, 9, 10 et 11 et  l'alimentation 5V du moteur sera fournie par la broche +5V de l'Arduino

<ul>
  <li> D1 sur IN1
</li>
  <li> D2 sur IN3
</li>
  <li> D5 sur IN2
</li>
  <li> D6 sur IN4
</li>
  <li> Vin sur Vcc
</li>
  <li> Gnd sur Gnd
</li>
</ul>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/arduino.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/arduino.png' class='alignnone size-medium' style='max-width:20%;'></a><figcaption>Figure - Schéma Arduino</figcaption></div></figure>
<h4>Code Arduino</h4>
Ce code fait tourner le moteur d'un tour, attend 2 secondes puis fait un tour dans l'autre sens avec un délai de 2s.

<hr><pre style='background-color:#F5F5F5;padding-left:1em;'><code>
#include <Stepper.h> //Inclusion de la bibliothèque Stepper

int nbPas = 2048; //Nombre de pas pour le moteur 28BYJ-48

#define IN1 8  //Broche IN1

#define IN2 9  //Broche IN2

#define IN3 10  //Broche IN3

#define IN4 11  //Broche IN4

Stepper moteur(nbPas, IN1, IN3, IN2, IN4); //Création de l'objet moteur

   

  void setup() {

    moteur.setSpeed(10); //On définit la vitesse à 10 tr/min

  }//Fin setup

   

  void loop() {

    moteur.step(nbPas);   //On avance de nbPas pas, c'est à dire un tour complet (sens horaire)

    delay(2000);          //pause de 2s

    moteur.step(-nbPas);  //On avance de -nbPas pas, c'est à dire un tour complet (sens anti-horaire)

    delay(2000);          //pause de 2s

  }//Fin loop

</code></pre><hr>
<h3>Mise en pratique avec ESP8266</h3> 
Nous utiliserons le même \pap 28BYJ-48

<h4>Liste du matériel</h4>
<ul>
  <li> Carte ESP8266 NodeMCU (ESP-12)
</li>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/mcu.jpeg'><img src='http://www.crepp.org/wp-content/uploads/2022/08/mcu.jpeg' class='alignnone size-medium' style='max-width:80%;'></a><figcaption>Figure - ESP12 NodeMCU</figcaption></div></figure>
  Cette carte fait partie de la famille des ESP8266 et se programme directement avec l’Éditeur Arduino. 

  L'installation des bibliothèques pour l'ESP12 est détaillée en annexe du document.

  <li> Driver ULN2803
</li>
  <li> Moteur \pap 28BYJ-48 ou équivalent (\pap unipolaire)
</li>
  <li> Câbles
</li>
</ul>
<h4>Branchements</h4>
Les numéros des broches sont différents sur les cartes ESP812 (modèle NodeMCU).

Voici les équivalences des broches entre le code et l'emplacement physique.

<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/nodeMCU.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/nodeMCU.png' class='alignnone size-medium' style='max-width:40%;'></a><figcaption>Figure - Broches ESP12</figcaption></div></figure>
Nous utiliserons les broches D1, D2, D5 et D6 et  l'alimentation 5V du moteur sera fournie par la broche Vin de l'ESP12

<ul>
  <li> D1 sur IN1
</li>
  <li> D2 sur IN3
</li>
  <li> D5 sur IN2
</li>
  <li> D6 sur IN4
</li>
  <li> Vin sur Vcc
</li>
  <li> Gnd sur Gnd
</li>
</ul>
<figure id=''><div class='cent' style='text-align:center;'><a href='http://www.crepp.org/wp-content/uploads/2022/08/nodemcu.png'><img src='http://www.crepp.org/wp-content/uploads/2022/08/nodemcu.png' class='alignnone size-medium' style='max-width:40%;'></a><figcaption>Figure - Schéma ESP12</figcaption></div></figure>
<h4>Code ESP12</h4>
Ce code fait tourner le moteur d'un tour, attend 2 secondes puis fait un tour dans l'autre sens avec un délai de 2s.

<hr><pre style='background-color:#F5F5F5;padding-left:1em;'><code>
  #include <Stepper.h> //Inclusion de la bibliothèque Stepper

  

  int nbPas = 2048; //Nombre de pas pour le moteur 28BYJ-48

  

  #define IN1 D1  //Broche IN1

  #define IN2 D5  //Broche IN2

  #define IN3 D2  //Broche IN3

  #define IN4 D6  //Broche IN4

  

  Stepper moteur(nbPas, IN1, IN3, IN2, IN4); //Création de l'objet moteur

     

    void setup() {

  

      moteur.setSpeed(10); //On définit la vitesse à 10 tr/min

  

    }//Fin setup

     

    void loop() {

  

      moteur.step(nbPas);   //On avance de nbPas pas, c'est à dire un tour complet (sens horaire)

      delay(2000);          //pause de 2s

      moteur.step(-nbPas);  //On avance de -nbPas pas, c'est à dire un tour complet (sens anti-horaire)

      delay(2000);          //pause de 2s

  

    }//Fin loop

</code></pre><hr>
  


</body></html>