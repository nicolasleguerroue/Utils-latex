<html><head><style>.cent {  display: block;  margin-left: auto;  margin-right: auto;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script><body style='margin-left:5%;margin-right:5%;margin-top:1%'><h4>Fichier générer depuis les sources Latex</h4><h5>Auteur : Nicolas Le Guerroué</h5><a href='index.html'><button class='btn btn-success' >Revenir au sommaire</button></a><hr> 

<h2 >Introduction</h2>
Ce document vise à présenter le projet Arduino et ses supports

Ce tutoriel a pour but également de présenter certaines possibilités d'Arduino en terme de langage et de 

ressources. 

Bien évidemment, cette section n'est pas du tout exhaustive.

<h3>Origines</h3>
Arduino est née en 2004 sous l'impulsion d'étudiants italiens souhaitant promouvoir l'accès à  l'électronique. 

Ils se rencontraient fréquemment dans un bar pour développer leur projet. 

Aujourd'hui, <u>Arduino</u> c'est:
<ul>
<li> Un langage de programmation basé sur le C++
</li>
<li> Une communauté
</li>
<li> Un projet Open-Source
</li>
</ul>
<h3>Supports</h3>
Arduino disposant d'une communauté assez vaste, de nombreux supports existent. 

Nous avons notamment le site officiel d'Arduino à l'adresse suivante:

<u>arduino.cc/Reference/en</u> 
Le langage Arduino est compatible avec les instructions du C++ dans la mesure ou le compilateur pour Arduino est g++.

Ainsi, les types composés comme les structures et classes sont supportés, tout comme le mot clé auto par exemple.

<h2 >Présentation</h2>
Nous utilisons des cartes Arduino Uno, basées sur les microcontrôleurs Atmega-328 du fabricant ATMEL.

Les microcontrôleurs sont des unités contenant dans un seul boîtier une mémoire, un processeur et des 

interfaces entrées-sorties pour ne citer que ces elements.

 

 Cela permet notamment de dialoguer avec des périphériques<span title="Voire section Protocoles de communication" style='color:grey;'><sup>[Note 41]</sup></span>

<h3>Le microcontrôleur</h3>
<h4>Alimentation</h4>
<h4>Tension d'alimentation</h4>
Le microcontrôleur doit être alimenté entre 1.8 V et 5.5 V. 

Il existe deux façon d'alimenter la carte Arduino: 

<ul>
<li> Via le port USB 
</li>
Le port USB délivre du 5V régulé avec un courant maximal de 500 mA (cas général)

<li> Via la broche Vin (connectique Jack femelle)
</li>
La carte Arduino possède un régulateur intégré de tension en 5 V, ce qui permet d'alimenter la carte entre 7V et 20V

</ul>
<h4>Courants d'entrées-sortie</h4>
<h4>Fréquence d'horloge</h4>
La carte Arduino comporte un oscillateur de 16 MHz même si en interne du microcontrôleur, 

un oscillateur de 8 Mhz est intégré.

Cela donne une idée des performances maximales de l'Arduino.

<h4>Mémoire</h4>
Ce microcontrôleur dispose de clé <b>32 ko</b> de clé <b>mémoire flash</b>, c'est à dire la mémoire 
pour stocker le programme téléversé vers la carte. 

Quand à la clé <b>mémoire vive (SRAM)</b>, elle est de <b>2 ko</b> et est utilisée pour les 
variables du programme en cours d’exécution. 

Cette mémoire peut être donc vite saturée lors de l'utilisation de grands tableaux par exemple. 

Enfin, le  possède une mémoire effaçable électriquement, appelée <b>EEPROM</b>\footnote{Référence: 
arduino.cc/Reference/EEPROM}, lors de l’exécution du programme. 

Cette mémoire occupe <b>1 ko</b> et chaque registre de cette mémoire, pouvant stocker un nombre 
codé sur 8 bits (type byte ou char), peut être modifiée 100 000 fois avant son arrêt définitif.

<h3>Caractéristiques électriques</h3>
Le microcontrôleur dispose d'entrée sorties permettant d’interagir avec des périphériques 

(Diodes électroluminescentes, capteurs, modules de communication\ldots) 

Les entrées sont deux types: 

<ul>
<li> entrée <b>numérique</b>: la valeur lue sera perçue comme un niveau logique 0 ou 1 sur les broches allant de 1 à 13</li>
<li> entrée <b>analogique</b>: Un Convertisseur Analogique-Numérique 10 bits est intégrés sur les broches A0, A1, A2, A3, A4 et A5</li>
De ce fait, le CAN <span title="Controller Area Network : Bus de terrain" style='color:blue;'>CAN</span> est possède une résolution de 4.84 mV avec une référence de tension à 5V\footnote{Il est également possible de changer la tension de référence de la carte Arduino 

arduino.cc/Reference/en/language/function/analog-io/analogreference}

</ul>
Astuce: Il est possible de configurer les broches analogique en broches digitales. 

<h2 >Le langage</h2>
<h3>Les types</h3>
Par défaut les types sont signés, c'est à dire que la plage de valeur pour un nombre codé sur <i>n</i> bits est compris entre \( \frac{-2^n}{2} \) et \( \frac{2^n+1}{2} \) 
Pour définir un type non signé, c'est à dire pour agrandir la plage positive, il suffit d'ajouter le mot clé <b>unsigned</b> avant les types concernés.
<h4>Les types supportés</h4>
<ul>
<li> <b>byte</b> <u>[1 octet]</u> </li>
Désigne la plus petite unité de mémoire allouable, permettant de stocker un nombre entier compris entre -127 et + 127.

<li> <b>unsigned byte</b> <u>[1 octet]</u> </li>
Idem mais la plage de valeur strictement positive

<li> <b>int</b>    <u>[2 octets]</u> </li>
Permet de stocker un nombre entier compris entre -32536 et +32536

<li> <b>unsigned int</b> <u>[2 octet]</u> </li>
Idem mais la plage de valeur strictement positive

<li> <b>float</b>  <u>[4 octets]</u> </li>
Permet de manipuler des réels

<li> <b>double</b> <u>[4 octets]</u> </li>
Idem, mais ce type est plus précis que le type float et demande plus de ressources au microcontroleur. 

<li> <b>char</b> <u>[1 octets]</u> </li>
Ce type est utilisé pour stcoker et traiter des caractères de la table ASCII.\@

<li> <b>String</b> <u>[4 octets]</u> </li>
String est un type élaboré qui permet de traiter des chaines de caractères.

</ul>
<h4>Les types non supportés</h4>
Les types <b>vector</b>, <b>array</b> et <b>tuple</b> ne sont pas supportés par le langage Arduino.
<h3>Les fonctions</h3>
<h4>Les fonctions mathématiques</h4>
En ce qui concerne les fonctions mathématiques, les fonctions trogonométriques sont incluses.

<h2 >Les broches d'interruption</h2>
Dans certains cas, il est souhaitable de récuperer la valeur d'une broche à tout moment du programme, même quand celui ci est occupé dans une tâche et même dans une fonction de temporisation <span title="Voir delay(), delayMicroseconds()" style='color:grey;'><sup>[Note 42]</sup></span>. 

Pour remédier à ce problème, on peut utiliser les \textcolor{blue} {\textbf{broches d'interruption}} qui permettent de récuperer la main sur l'ensemble du programme lorsque'un évènement survient sur une broche.

Concrètement, lorsque un évènement  <i>e</i> survient sur la broche <i>b</i>, la fonction <i>f</i> est appelée, quelque soit l'état du programme principal. 
Prenons le cas d'un bouton qui doit changer l'état d'une LED à n'importe quel moment du programme.

<hr><pre style='background-color:#F5F5F5;padding-left:1em;'><code>
	int ledPin = 13;    //Led interne

	int BOUTON = 2;  //Bouton relié à la broche 2 avec une résistance de charge

	

	volatile int state = LOW;  //Etat courant de la LED

	

	void setup() {

	  

	  Serial.begin(9600);//Vitesse de communication à 9600 bit/s

	  

	  pinMode(ledPin, OUTPUT);                //Led mise en sortie

	  pinMode(BOUTON, INPUT_PULLUP);    //Bouton mis en entrée

	  

	  attachInterrupt(digitalPinToInterrupt(BOUTON), onEvent, CHANGE);  //Appel de la fonction onEvent à chaque changement de front du bouton

	  Serial.println("Init");

	}

	

	void loop() {

	  

	 delay(5000); //Pause du programme principal

	  

	}

	

	void onEvent() {

	  

	  state = !state; //Inverse l'état de la LED

	  

	  if(state){

		Serial.println("ON");

	  }else{

		Serial.println("OFF");

	  }

	   digitalWrite(ledPin, state); //Met à jour l'état de la LED

	}

	

</code></pre><hr>
Ici, quelque soit l'action effectuée dans la fonction loop, dès qu'un front montant est détecté sur la broche BOUTON (2), 

la fonction onEvent() sera exécutée et changera l'état de la LED à chaque front

<h4>Mode d'interruption</h4>
Il existe différents modes pour les broches :

<ul>
	<li> RISING: front montant
</li>
	<li> FALLING: Front descendant
</li>
	<li> CHANGE: Front montant et descendant
</li>
</ul>
<h4>Chronogrammes d'interruption</h4>
\begin{numeric}{Exemple avec mode RISING}

	BOUTON & LLLLLLLHLLLLLLLLLL 

	loop &  7D{EXECUTION} 6D{PAUSE} 7D{REPRISE} 

	onEvent & 7D{INACTIVE} 6D{EXECUTION} 7D{INACTIVE} 

\end{numeric}

\begin{numeric}{Exemple avec mode FALLING}

	BOUTON & LLLLLLLHLLLLLLLLLL 

	loop &  8D{EXECUTION} 6D{PAUSE} 6D{REPRISE} 

	onEvent & 8D{INACTIVE} 6D{APPEL} 6D{INACTIVE} 

	\end{numeric}

\begin{numeric}{Exemple avec mode CHANGE}

	BOUTON & LLLLLLLHHHHHHHHHHHHHHLLLLLLLLLLLLLL 

	loop &  7D{EXECUTION} 8D{PAUSE} 6D{REPRISE} 8D{PAUSE} 6D{REPRISE}  

	onEvent & 7D{INACTIVE} 8D{EXECUTION} 6D{INACTIVE} 8D{EXECUTION} 6D{INACTIVE}

	\end{numeric}

<h2 >Synthèse Arduino</h2>
<h4>Matériel</h4>
<ul>
<li> Mémoire Flash: 32 ko
</li>
<li> Mémoire Vive (SRAM): 2 ko 
</li>
<li> Fréquence d'horloge: 16 MHz 
</li>
</ul>
<h4>Électriques</h4>
<ul>
<li> Impédance d'entrée: \(> 1 MOhm\)
</li>
<li> Courant de sortie par broche: \(40\) mA maximum
</li>
<li> Courant de sortie pour toutes les broches entrée-sorties: \(200\) mA
</li>
</ul>
<h3>Calcul d'une résistance</h3>
\( U = RI \)

avec 

<ul>
    <li> U la tension en V (Volt)
</li>
    <li> R la résistance en \(\Omega\) (Ohm)
</li>
    <li> I le courant en A (Ampère)
</li>
</ul>
Or, 

\( R = \frac{U}{I} \)

On cherche à déterminer la valeur de R avec un I imposé et un \(U_{led}\) imposée par la couleur de la led. 

D'où : 

\( R_{led} = \frac{U_{arduino} - U_{led}}{I_{led}}\)

\( R_{led} = \frac{5-1.6}{0.01} = 340 \Omega\)


</body></html>