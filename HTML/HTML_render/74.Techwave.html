<html><head><style>.cent {  display: block;  margin-left: auto;  margin-right: auto;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script><body style='margin-left:5%;margin-right:5%;margin-top:1%'><h4>Fichier générer depuis les sources Latex</h4><h5>Auteur : Nicolas Le Guerroué</h5><a href='index.html'><button class='btn btn-success' >Revenir au sommaire</button></a><hr><h2 >Processus global</h2>
Lien du planning  :<a class="alert-link">https://docs.google.com/spreadsheets/d/1A7SzA6MrE79ad0Wu_JOUoUsbwYkRI9X0kK3oco4b4y0/edit?usp=sharing</a>
Voici les différentes étapes et axes de travail du projet de stage. Toutes ces étapes sont détaillées par la suite.

<h3>Processus Devis</h3>
<ul>
<li> Extraction des données clients (OCR). 
</li>
Depuis plusieurs supports clients (PDF, mails, Excel),pouvoir extraire les données pour les manipuler plus facilement (codification, recherche des prix en ligne...)

<li> Récupération des prix, des délais de livraison et des durées de vie des composants par les fournisseurs et distributeurs.
</li>
<li> Gestion des devis PCB
</li>
<li> (Gestion des données documentaires (accès simplifié des plans, datasheets pour les services suivants))
</li>
</ul>
<h3>Processus Codification</h3>
<ul>
<li> Reduction de l’utilisation d’Excel via la mise en place d’outils de traitement plus automatiques. Ces outils visent à importer automatiquement les données en provenance des fournisseurs (API) pour faire une codification automatique.
</li>
<li> En découle une gestion attentive des doublons de référence lors de la codification automatique.
</li>
</ul>
<h3>Processus Approvisionnement</h3>
<ul>
<li> Mise à jour régulière des prix et délai pour les commandes.
</li>
</ul>
<h3>Synthèse du processus</h3>
<figure id=''><div class='cent' style='text-align:center;'><img src='empty' class='alignnone size-medium' style='max-width:90%;'><figcaption>Figure - Processus de traitement global</figcaption></div></figure>
<h3>Les limites actuelles</h3>
Voici la liste des limites et des contraintes pour la mise en place des outils :

<ul>
<li> Il y a une limitation du nombre de licences X3, actuellement, tout le monde ne peux pas
</li>
utiliser X3

<li> Taille du serveur pour stocker des fichiers (datasheets et plans peuvent poser un problème
</li>
de taille, 7000 fichiers. Avec une moyenne de 10 Mo par fichier, cela fait plus de 70 Go de stockage nécessaires. Ce point sera abordé dans la gestion des datasheets lors de la récupération des données en ligne.

<li> Pour chaque API, nous sommes limités à 1000 requêtes par jour.
</li>
</ul>

%<h1 class=''>Annexes</h1>
<h2 >Connexions aux API</h2>
<h3>Informations API</h3>
Ce tableau récapitule l'ensemble des informations des API utilisées<span title="Utile en cas de mise à jour de l'API" style='color:grey;'><sup>[Note 21]</sup></span>

<h4>DigiKey</h4>
\begin{tabular}{|p{3cm}|p{13cm}|}

  \hline

  <b>Nom</b> & <b>Valeur</b> 
  \hline

Url access & <a class="alert-link">https://sandbox-api.digikey.com/v1/oauth2/authorize</a>
  \hline

ClientID<span title="Données via l'application API sur le compte \url{www.digi-key.com" style='color:grey;'><sup>[Note 22]</sup></span>} & h7E4dTHl4UNGf6SV7byTr05JS3KyKrGr

 \hline

 SecretKey & PwhcS2Hmi0HhNoAG

 \hline

 CustomerID & 8509437 

  \hline

 API version & 3.0

  \hline

  Output Format & JSON

  \hline

  Requests / day & 1000

  \hline

\end{tabular}

Le service d'authentification de Digi-key nécessite un serveur pour rediriger le premier résultat de Digi-key (code).

<h4>Mouser</h4>
\begin{tabular}{|p{3cm}|p{13cm}|}

  \hline

  <b>Nom</b> & <b>Valeur</b> 
  \hline

Url & <a class="alert-link">https://api.mouser.com/api/v1.0/search/partnumber</a> 
 \hline

ApiKey &9b4489a8-bea0-48ec-9e51-60e5117ebf7b

  \hline

Api version & 1.0 

  \hline

  Output Format & JSON

  \hline

  Requests / day & 1000

  \hline

\end{tabular}

<h4>Farnell</h4> Compte ALine => pettona
E14 : 

login : nicolasleguerroue2

MOT DE PASSE : Bk8WPDkxpkACPqN

API KEY = rc772yuvs86tvjnrsvah6z5e 

\begin{tabular}{|p{3cm}|p{13cm}|}

  \hline

  <b>Nom</b> & <b>Valeur</b> 
  \hline

Url & <a class="alert-link">https://api.element14.com/catalog/products</a>
 \hline

 ApiKey & ndukznmj3n4yq524y6hnxnme

  \hline

 CustomerId & 5174230003

  \hline 

  SecretKey & gaD8uChe

  \hline

  Output Format & JSON

  \hline

  Requests / day & 1000

  \hline

\end{tabular}

<h4>Arrow</h4>
\begin{tabular}{|p{3cm}|p{13cm}|}

  \hline

  <b>Nom</b> & <b>Valeur</b> 
  \hline

Url & <a class="alert-link">http://api.arrow.com/itemservice/v3/en/search/token</a>
 \hline

 Login & techwavemanufacturing2

  \hline

 CustomerId & 5174230003

  \hline 

  ApiKey & 7917a314eaea1f70cb0348157a001fd0e4874e6647bfb33f6c12210e4fb4e2a5

  \hline

  Api version & 3 

  \hline

  Output Format & JSON

  \hline

  Requests / day & 1000

  \hline

\end{tabular}

<h4>Future</h4>
\begin{tabular}{|p{3cm}|p{13cm}|}

  \hline

  <b>Nom</b> & <b>Valeur</b> 
  \hline

Url & <a class="alert-link">https://api.futureelectronics.com/api/v1/pim-future/lookup</a>
 \hline

ApiKey & 9b4489a8-bea0-48ec-9e51-60e5117ebf7b

  \hline

Api version & 1 

  \hline

  Output Format & JSON

  \hline

  Requests / day & 1000

  \hline

\end{tabular}

<h3>Formats de sortie après recherche des API</h3>
Il est possible d'exporter les résultats sous 3 formes : 

<ul>
<li> JSON
</li>
<li> CSV
</li>
<li> HTML
</li>
</ul>
<h4>Format JSON</h4>
Ce format sera utilisé pour communiquer entre le serveur Web et le programme récupérant les données en provenance des API.

\begin{Python}{Fichier de sortie JSON}

{

    "status" : "OK"

    "message" : "Message",

    "result" : 

    [{

        "fabricantPartNumber": "fabricantPartNumber",

        "wishedFabricantPartNumber": "wishedFabricantPartNumber",

        "unitPrice": "0.058",

        "isBestPrice": "true",

        "availableOrderQuantity": "true",

        "isAvailableForOrder": "true",

        "wishedQuantity": "10",

        "directOrder": "true",

        "minimalOrderQuantity" : "1",

        "groupeOrder" : "1",

        "apiName": "apiName",

        "warning": "warning message from API",

        "realItem": "true",

        "similarItem" :"false",

        "isObsolete" : "false"

    

    },

    {...}

    ]

}

</code></pre><hr>
<h4>Format CSV</h4>
Ce format a été développé pour une utilisation particulière afin de réaliser des devis sans l'interface Web proposée par la section <b>Architecture</b>
\begin{verbatim}

    Reference demandee;Reference trouvee;PU Mouser;PU Farnell;PU Future;

    MOQ Mouser;MOQ Farnell;MOQ Future;Quantitee Mouser;Quantitee Farnell;

    Quantitee Future;Delais Mouser;Delais Farnell;Delais Future;

    Description Mouser;Description Farnell ;Description Future;Obsolete

    Mouser ?;Obsolete Farnell ?;Obsolete Future ?

    1UX99;Aucune reference trouvee;0.0;0.0;0.0;;;;

    0;0;0;2 semaines;2 semaines;2 semaines;Inconnue;Inconnue;

    Inconnue;False;False;False

\end{verbatim}

<h4>Format HTML</h4>
Ce format peut être utilisé pour le développement du programme et pour garder un historique des résultats<span title="Le format est plus lisible que le JSON ou CSV" style='color:grey;'><sup>[Note 23]</sup></span>

<figure id=''><div class='cent' style='text-align:center;'><img src='empty' class='alignnone size-medium' style='max-width:52%;'><figcaption>Figure - Format HTML</figcaption></div></figure>
<h2 >Connexion à la base de données d'X3</h2>
<h3>Formats d'entrée / sortie de l'utilitaire de lecture de la BDD X3</h3>
<h4>Exécution du programme</h4>
Le programme de lecture de la BDD X3 devra être exécuté comme suis :

\begin{verbatim}

    java -jar LectureBDDX3 input.json output.json

\end{verbatim}

Le fichier input.json pourra être remplacer par stdin pour que le programme récupère le JSON à partir de l’entrée standard.

Le fichier output.json pourra être remplacer par stdout pour que le programme écrive son résultat dans la sortie standard.

Si le programme est invoqué sans paramètres, le programme utilisera stdin et stdout par défault.

<h4>Format d'entrée</h4>
Le format du fichier input.json sera (exemple) :

\begin{Python}{Fichier d'entrée JSON}

    {

        "request" :  "SELECT ab, cd, ef FROM test WHERE abc = ? AND cde = ?",

        "result_values" : [

            { "type" : "string", "out_name" : "ijk", "db_name" : "ab" },

            { "type" : "bool", "out_name" : "lmn", "db_name" : "ab" },

            { "type" : "int", "out_name" : "opq", "db_name" : "ab" }

        ],

        "params" :  [

            { "type" : "string", "value" : "abc_val" },

            { "type" : "int", "value" : 123 }

        ]

    }

</code></pre><hr>
Types supportés par les paramètres : string, int, float, bool, date

<h4>Format de sortie</h4>
Le format du fichier output.json sera (exemple) :

\begin{Python}{Fichier de sortie JSON}

    {

        "status": "OK",

        "message" : "OK",

        "results" : {

            "ijk":"test",

            "lmn": true,

            "opq": 123   

        }

    }

</code></pre><hr>
Le noms des clées dans l'objet results doit correspondre à la valeur de out name dans la configuration d'entrée.

 

En cas d’erreur le fichier output.json sera de la forme :

\begin{Python}{Fichier de sortie JSON Erreur}

    {

        "status": "NOK",

        "message": "Error message"

    }

</code></pre><hr>
<h3>Formats d'entrée / sortie de l'utilitaire d'écriture à la BDD X3</h3>
<h4>Exécution du programme</h4>
Le programme d’écriture de la BDD X3 devra être exécuté comme suis :

\begin{verbatim}

    java -jar EcritureBDDX3 input.json output.json

\end{verbatim}

Le fichier input.json pourra être remplacer par stdin pour que le programme récupère le JSON à partir de l’entrée standard.

Le fichier output.json pourra être remplacer par stdout pour que le programme écrive son résultat dans la sortie standard.

Si le programme est invoqué sans paramètres, le programme utilisera stdin et stdout par défault.

Ce programme aura aussi un fichier config.json décrivant les caractéristiques de chacune des commandes acceptées.

<h4>Format du fichier de config</h4>
Le format du fichier config.json sera (exemple) :

\begin{Python}{Fichier de config JSON}

    [

        {

            "command" : "ABCDE",

            ...

        },

        { ... }

    ]

</code></pre><hr>
	

Ici chaque objet de la liste représente une commande disponible.

Ce fichier sera fixe et n'est pas sensé être modifié par le programme, juste lu.

<h4>Format d'entrée</h4>
Le format du fichier input.json sera (exemple) :

\begin{Python}{Fichier d'entrée JSON}

    {

        "command":  "ABCDE",

        "params":  [

            { "name": "abc", "value": "abc_val" },

            { "name": "def", "value": 123 }

        ]

    }

</code></pre><hr>
On y précise la commande que l'on souhaite exécuter, puis les paramètres de cette commande. Les paramètres serons souvent composés de la liste des objets à insérer dans la BDD mais peuvent aussi différer d'une commande à l'autre au besoin.

<h4>Format de sortie</h4>
Ce programme ne faisant qu’écrire dans la BDD, il n’a rien d’intéressant à revoyer. Toutefois on revoie quand même quelque chose pour pouvoir gérer les éventuelles erreurs. Le format du fichier output.json sera donc simplement (exemple) :

\begin{Python}{Fichier de sortie JSON}

    {

        "status": "OK" / "NOK",

        "message": "Message d’erreur si erreur",

    }

</code></pre><hr>
<h2 >Structure et chemins du site web</h2>
<h3>Page d’accueil</h3>
<h4>./ (ou ./index.html)</h4>
Page d’accueil contenant des infos générales sur le site ainsi qu’un accès simple à chacune des fonctionnalités du site.

<h3>Recherche des composants sur l’API fournisseur</h3>
<h4>./rechercheAPIFournisseur.html</h4>
Page permettant d’importer un BOM sous format CSV et de vérifier l’intégralité des composants de cette BOM sur les API des fournisseurs. Une fois les requêtes aux API terminées, l’utilisateur est redirigé vers la page resultatAPIFournisseur.html. Les résultats de l’API est sauvegardé sous forme d’un fichier html sur le serveur pour garder une trace de la requête si on veut la revoir plus tard et être récupéré par la page resultatAPIFournisseur pour l’affichage.

 

Le fichier CVS importé doit être sous ce format :

<ul>
<li> Séparé avec des ; | String échappés avec des " (Format par défaut d’export Excel en CSV)
</li>
<li> Si le CSV ne vient pas de l’export d’Excel, ces options sont modifiables au moment de l’exportation
</li>
<li> Chaque ligne du fichier CVS correspond à un composant de la BOM
</li>
<li> Les 3 colonnes du CSV doivent correspondent, dans l’ordre à : (La référence fabricant du composant, la quantité de ce composant requis par carte, une description de ce composant)
</li>
<li> Le fichier ne doit pas comporter de 1ere ligne nommant chacune des colonnes
</li>
</ul>
<h4>./resultatAPIFournisseur.html</h4>
Sur cette page, l’utilisateur peut consulter les résultats des API pour chaque composant :

<ul>
<li> Il peut consulter les informations de prix, disponibilité, livraison, … pour chaque composant 
</li>
<li> Pour les composants concernés, il peut choisir parmi les composants alternatifs trouvés par les API et en sélectionner un comme remplacement.
</li>
</ul>
<h3>Gestionnaire des fiches composants</h3>
<h4>./fichesCompo.html</h4>
Sur cette page l’utilisateur peut rechercher des fiches composant préalablement enregistrées. Cette recherche se fait dans un champ unique, avec une liste déroulante de choix correspondants à la recherche se mettant à jour à mesure que l’utilisateur tape. La recherche se fait sur :

<ul>
<li> La référence fabricant (Contenue dans la BDD MySQL)
</li>
<li> La description du composant (Contenue dans la BDD MySQL)
</li>
<li> La référence AODE (Recherche dans la BDD X3 à partir des références fabricant présentes dans la BDD MySQL)
</li>
</ul>
Une fois la recherche terminée, l’utilisateur peut télécharger la fiche composant correspondante.

L’utilisateur a aussi à disposition une interface pour ajouter manuellement une fiche ou en supprimer une de la base.

<h3>Utilitaire transcription de tableaux PDF</h3>
<h4>./transcriptionPDF.html</h4>
Sur cette page, l’utilisateur peut upload un fichier PDF contenant un tableau de données et récupérer un fichier CSV avec les dites données. La page informe l’utilisateur de l’avancement de la transcription pendant le traitement puis lui permet de télécharger le fichier CSV.

<h3>Utilitaire relances fournisseurs</h3>
<h4>./relancesFournisseurs.html</h4>
Sur cette page, l’utilisateur peut consulter les dernières relances fournisseurs envoyées automatiquement. Plusieurs pages sont disponibles pour ne pas à avoir à charger l’intégralité des données à chaque visite de la page.

<h2 >Structure du répertoire Python</h2>
<ul>
<li> API
</li>
<ul>
<li> <span class='badge badge-success'>ArrowAPI.py</span> : Connexion à l'API Arrow et gestion des composants</li>
<li> <span class='badge badge-success'>ArrowItem.py</span> : Extraction des information pour les composants Arrow</li>
<li> <span class='badge badge-success'>AvnetAPI.py</span> : Connexion à l'API Avnet et gestion des composants</li>
<li> <span class='badge badge-success'>AvnetItem.py</span> : Extraction des information pour les composants Avnet</li>
<li> <span class='badge badge-success'>DigiKeyAPI.py</span> : Connexion à l'API Arrow et gestion des composants</li>
<li> <span class='badge badge-success'>DigiKeyItem.py</span> : Extraction des information pour les composants Digi-key</li>
<li> <span class='badge badge-success'>FarnellAPI.py</span> : Connexion à l'API Arrow et gestion des composants</li>
<li> <span class='badge badge-success'>FarnellItem.py</span> : Extraction des information pour les composants Farnell</li>
<li> <span class='badge badge-success'>FutureAPI.py</span> : Connexion à l'API Arrow et gestion des composants</li>
<li> <span class='badge badge-success'>FutureItem.py</span> : Extraction des information pour les composants Future</li>
<li> <span class='badge badge-success'>MouserAPI.py</span> : Connexion à l'API Arrow et gestion des composants</li>
<li> <span class='badge badge-success'>MouserItem.py</span> : Extraction des information pour les composants Mouser</li>
<li> <span class='badge badge-success'>Item.py</span> : Informations d'un Item</li>
<li> <span class='badge badge-success'>ItemManager.py</span> : Gestionnaire de liste d'Item</li>
<li> <span class='badge badge-success'>ThreadAPI.py</span> : Bilbiothèque pour la recherche API en multi-threading</li>
</ul>
<li> Backups
</li>
<ul>
<li> 2021
</li>
<li> ....
</li>
</ul>
<ul>
<li> counter.txt : Compteur de requêtes API  journalières<span title="Remis à zéro tous les jours" style='color:grey;'><sup>[Note 24]</sup></span>
</li>
</ul>
<li> JSON
</li>
<ul>
<li> inputPartNumbers.json : Fichier d'entrée des composants à chercher
</li>
<li> outputPartNumbers.json : Fichier de sortie des résultats des API
</li>
</ul>
<li> Utils
</li>
<ul>
<li> <span class='badge badge-success'>CSV.py</span> : Bibliothèque de lecture/Ecriture de fichiers CSV</li>
<li> <span class='badge badge-success'>Utils.py</span> : Bilbiothèque avec des fonctions de traitement</li>
<li> <span class='badge badge-success'>Mail.py</span> : Bibliothèque d'envoi de mails</li>
</ul>
</ul>
<ul>
<li> <span class='badge badge-primary'>main.py</span> : Code principal</li>
</ul>
<h3>Notes sur le multi-threading</h3> 
Chaque <span id='multithrading'></span> requêtes API est exécutée en parallèle pour optimiser le temps global d'exécution.
La classe <span class='badge badge-primary'>ThredAPI</span> est instanciée dans <span class='badge badge-primary'>main</span> et le constructeur attend les paramètres suivants : 
<ul>
<li> threadID : Identifiant du thread [0...N]
</li>
<li> threadName : Nom du thread ("Mouser Thread"...)
</li>
<li> ItemManager : Instance de la classe <span class='badge badge-primary'>ItemManager</span>, par héritage les classes des API (<span class='badge badge-primary'>MouserAPI</span>, <span class='badge badge-primary'>FarnellAPI</span>...)</li>
<li> references : Liste des références à chercher avec les API
</li>
<li> quantities : Liste des quantités souhaitées pour chaque référence demandée
</li>
<li> exportFile : Fichier de sortie HTML (logs)
</li>
<li> itemList : Liste vide qui stockera tous les composants trouvés (passage par référence)
</li>
<li> function : Fonction à appeler en multi-threading
</li>
</ul>
<h3>Modules Python nécessaires</h3>
Le code pour récuperer les données en provenance des API est disponible pour les versions python 2.X et 3.X

Le module <span class='badge badge-success'>requests</span> est nécessaire, tout comme les modules 
<span class='badge badge-success'>datetime</span>, <span class='badge badge-success'>os</span>, <span class='badge badge-success'>threading</span>, <span class='badge badge-success'>time</span> et <span class='badge badge-success'>json</span> qui sont inclus par défaut.
<h2 >A faire</h2>
- Récupérer information compte Farnell 

- Relance clé API Avnet !

- Gestion si plusieurs composants trouvés mais le meilleurs prix est obsolète !

- Finir documentation code (Avnet+Digi-key)+ diagrammes

- Vérifier code d'erreur execThread si len(quantities)!=len(references)


<h2 >Mise à jour des informations devis</h2>
<h3>Présentation du besoin</h3>
Entre la création d'un devis et la commande, il peut se passer plusieurs jours voir plusieurs semaines. Il convient donc de mettre à jour les informations du devis car le service Approvisionnement se base sur les données Devis.

<h3>Pistes suggérée</h3>
En faisant une recherche en ligne avec les API, il est possible de récupérer les prix et informations des composants du devis.

En cette période ou les composants change de prix et les disponibilité fluctuent rapidement, il se peut que certains composants n'existent plus entre le devis et la commande.

<h3>Fréquence de rafraîchissement</h3>
La fréquence de rafraîchissement maximale dépend du nombre de requêtes possibles par API. En moyenne, ce nombre vaut 1000.

Deux politiques de rafraîchissement envisagées : 

<ul>
<li> Une mise à jour automatique tous les X jours.
</li>
<li> Une mise à jour sur demande.
</li>
</ul>
<h4>Mise à jour automatique</h4>
Ce choix semble compliqué car au vu du nombre maximal de requêtes, nous pouvons avoir le scénario suivant : 

<ul>
<li> Lundi : devis de 45 lignes réalisé, cela implique 45 requêtes.
</li>
<li> Mardi : 3 devis de 25 lignes. Si mise à jour du devis de lundi, cela fait 120 requêtes à la journée
</li>
<li> Mardi : 2 devis de 30 lignes. Si mise à jour du devis de lundi et mardi, cela fait 180 requêtes à la journée
</li>
<li> Mardi : 4 devis de 20 lignes. Si mise à jour du devis de lundi,mardi mardi et mercredi, cela fait 260 requêtes à la journée
</li>
</ul>
En suivant ce rythme, on voit bien qu'au bout d'une semaine ou deux, le nombre de requêtes par jour dépasse les 1000.

<h4>Mise à jour sur demande</h4>
Avant de faire une commande pour une BOM, il faudrait mettre à jour la BOM spécifique.

Avec une moyenne de XX lignes de commande par jour, cela représente XXX requêtes par jour, ce qui est plus acceptable.


<h2 >Importation des composants</h2>
<h3>Définition du besoin</h3>
Pour chaque nouveau composant venant d'un devis, il faut le codifier selon un format de donnée précis (cf GEN).

Lorsque le devis est terminé, on récupère les composants au format JSON ou CSV et on importe les composants en "masse". Cela permet d'automatiser la codification car les données en provenance des API sont fiables.

<h2 >Gestion des formats client</h2>
Les données des clients proviennent de différents supports (PDF, Excel...)

En ce qui concerne les fichiers PDF, il est souhaitable de lire les données du document pour les mettre dans un format exploitable (Fichier CSV, JSON...).

<h2 >Gestion des composants de la BOM</h2>
<h3>Présentation du besoin</h3>
Il faut saisir et mettre à jour régulièrement le prix des composants. Le temps de recherche est long et fastidieux. Les composants sont recherchés sur les fournisseurs/distributeurs suivants  :

<ul>
<li> Farnell (1000 requêtes par jour, clé disponible, en attente de la <b>secretKey</b> et <b>custormerID</b>)</li>
<li> Mouser ( 1000 requêtes par jour, clé disponible, pas de réduction pour Techwave)
</li>
<li> Digi-key (1000 requêtes par jour, clé disponible, prix réduits)
</li>
<li> Arrow (clé disponible, prix réduits)
</li>
<li> Future (clé disponible, prix réduits)
</li>
<li> Avnet (en attente de clé)
</li>
</ul>
 RS-Component ne possède pas d'API et TTI met en place une API pour l'Europe cet été.

 

<h3>Piste suggérée</h3>
En récupérant les données fournisseurs avec des API<span title="Interface de Programmation d'Application" style='color:grey;'><sup>[Note 25]</sup></span>, il est possible de connaitre la quantité, le prix et le temps de livraison estimé en temps réel.Une recherche d'un composant est considéré par la suite comme étant une requête.

Comme énoncé dans les limites, chaque API limite à 1000 requêtes par jour.

L’objectif est d’obtenir des prix fiables car ces derniers sont en provenance des fournisseurs.

Pour les composants obsolètes, recherche dans le stock (référence, type [CMS]...) et en cas de non correspondance, recherche en ligne.

<h3>Gestion des API</h3>
<h4>format d'entrée des API</h4>
Lors d'une recherche d'un composant pour une API, il convient de donner les éléments suivants : 

<ul>
<li> Référence fabricant souhaitée
</li>
<li> Quantité souhaitée
</li>
</ul>
<h4>Format de sortie des API</h4>
Pour une référence de composant données, chaque API va nous retourner une liste de composants ayant les attributs suivants : 

<ul>
<li> Référence fabricant
</li>
<li> Catégorie
</li>
<li> Lien de la documentation
</li>
<li> Cyle de vie (Obsolète, nouveau produit...)
</li>
<li> Description
</li>
<li> Fabricant
</li>
<li> Disponibilité
</li>
<li> MOQ
</li>
<li> Group Order
</li>
</ul>
Les données en provenance des API sont au format JSON ou XML.

Les données sont récupérées via les API en multithreading<span title="Se reporter à la page \pageref{multithrading" style='color:grey;'><sup>[Note 26]</sup></span> pour plus d'informations}, c'est à dire que les n fournisseurs/distributeurs sont solicités en même temps pour réduire le temps d'attente.

Une fois que les données brutes ont été reçues, ces données sont traitées et mises en forme sous forme de liste de composants dans un format spécifique (JSON)

<figure id=''><div class='cent' style='text-align:center;'><img src='empty' class='alignnone size-medium' style='max-width:100%;'><figcaption>Figure - Utilisation des API</figcaption></div></figure>
<h4>Données composées</h4>
Ces données peuvent avoir un format non conforme mais après traitement, nous pouvons en déduire les attributs suivants :

<ul>
<li> Prix unitaire
</li>
<li> Quantité disponible
</li>
<li> Etat du composant (obsolète, nouveau produit...)
</li>
</ul>
<h4>Traitement des données</h4>
Les composants sont traités de la façon suivante :

<ul>
<li> On recherche tous les composants disponibles en quantités suffisante et on met de coté les composants oboslètes et similaires
</li>
<li> On cherche le meilleur prix parmi les composants trouvés en tenant compte des MOQ<span title="Minimal Order Quantity" style='color:grey;'><sup>[Note 27]</sup></span>
</li>
<li> Si aucun composant n'est trouvée, on retourne un composant "inexistant"
</li>
</ul>
En analysant ces données, nous pouvons définir des statuts pour chaque composant : 

<ul>
<li> Composant existant / inexistant
</li>
<li> Composant obsolète/ non obsolète
</li>
<li> Composants similaire / non similaire
</li>
<li> Composant au meilleur prix
</li>
</ul>
Un composant est défini come non existant si aucune référence pour le composant demandé n'est trouvée.

Si des composants sont trouvés mais sont tous en quantité insuffisante, le programme retourne le composant avec le meilleur prix.

Un composant est défini comme "similaire" lorsque la référence demandée n'est pas strictement incluse dans la référence trouvée.

Par exemple, si on cherche un composant <b>BC337</b> et que l'API retourne une référence <b>BC537</b>, le composant est considéré comme "similaire".
<figure id=''><div class='cent' style='text-align:center;'><img src='empty' class='alignnone size-medium' style='max-width:110%;'><figcaption>Figure - Processus de traitement des données</figcaption></div></figure>
<h4>Gestion des composants obsolètes</h4>
Les composants avec la référence exacte mais obsolètes sont supprimés de la liste principale mais apparaissent dans une liste "obsolète"

<h4>Gestion  des composants similaires</h4>
Les composants similaires sont traités de la même manière que les composants avec la référence exacte

<h4>Quelques cas d'usage</h4>
Cas d'usage 1 : 

Pour un composant demandé, on peut avoir : 

<ul>
<li> 0 composant avec la référence exacte trouvée
</li>
<li> 1 composants avec la référence exacte obsolète
</li>
<li> 2 composants similaires
</li>
</ul>
<b>Le choix devra donc se porter sur le meilleur composant similaire</b>
Cas d'usage 2 : 

<ul>
<li> 1 composant avec la référence exacte trouvée
</li>
<li> 0 composant avec la référence exacte obsolète
</li>
<li> 5 composants similaires
</li>
</ul>
<b>Le choix devra se porter entre le meilleur prix du composant exact ou la référence similaire.</b>
<h2 >Devis PCB</h2>
<h3>Présentation du besoin</h3>
Actuellement, les demandes de prix sont envoyé par mail aux fabricants des PCB (SAve, ICAP, Wurth PCB). L'entreprise est donc dépendante du temps de réponse des fabricants.

<h3>Piste suggérée</h3>
En fonction du type de PCB demandée, il convient d'aller sur le site du fabricant et d’utiliser l'outil de demande de prix en ligne.

Cet outils est une page WEB ou il faut saisir les paramètres du PCB (technologie multicouche, flex, hyper-fréquence)

.

Nous avons essayé de faire le processus avec une APi (Safe en l’occurrence) mais en dehors des circuits double-face, le nombre de paramètre est beaucoup trop important pour pouvoir être renseigné par notre site internet.

Les fabricants avec les outils de demande de prix sont les suivants : 

<ul>
<li> Safe
</li>
<li> ICAP
</li>
<li> Wurth PCB
</li>
</ul>
<h2 >Gestion de la documentation</h2>
<h3>Présentation du besoin</h3>
Le service Devis a parfois besoin de la datasheet ou d’un plan, le service Codification aussi

pour visualiser le composant. Il est donc souhaitable d’éviter le doublon de l’étape "recherche de datasheet" sur le Web.

<h3>Piste suggéré</h3>
Une première piste est la récupération des datasheets par certaines API fournisseurs. Il ets possible de récupérer le lien des datasheets et de les afficher sur le site<span title="Recherceh par référence fabricant" style='color:grey;'><sup>[Note 28]</sup></span>

Idéalement, il faudrait supprimer les datasheets considérées comme obsolètes.

L’outil X3 n'est pas capable de supporter l’importation de fichier PDF.

Nous pourrions utiliser un CMS pour la gestion des Documents (GED) mais ceux si sont parfois payants et la taille des données manipulées (lien HTML) ne justifie pas l'utilistion d'un GED.

Parmi les GED existants, notons : 

<ul>
<li> Xoops
</li>
<li> Nuxeo
</li>
<li> Alfresco
</li>
<li> KnowledgeTree
</li>
<li> Drupal
</li>
</ul>

%<h1 class=''>Architecture</h1>
<h2 >Machine linux</h2>
	

Le composant technique le plus important de ce projet est un serveur/VM linux où serons hébergées l’intégralité des fonctionnalités du projet. Ce serveur devra :

<ul>
<li> Pouvoir être accédé depuis le réseau interne de l’entreprise (Accès à un service web)
</li>
<li> Pouvoir avoir accès à Internet (Pour aller interroger les API fournisseurs)
</li>
<li> Pouvoir avoir accès au serveur interne brzadx01 (serveur host du système X3 / BDD X3) 
</li>
</ul>
\begin{tabular}{|p{1.5cm}|p{6cm}|p{6cm}|p{2cm}|}

  \hline

  <b>N°</b> & <b>Tâche</b> & <b>Description</b> & <b>Nécessite</b> 
  \hline

 1-1 & Déploiement du serveur /VM linux & La machine linux est déployée & - 

 \hline

1-2 &	Accès par le réseau local de l’entreprise &	La machine linux doit être joignable par le réseau interne de l’entreprise & - 

  \hline

1-3	& Accès à Internet & La machine linux doit avoir accès à Internet & - 

\hline

1-4	& Accès à brzadx01 & La machine linux doit avoir accès au serveur brzadx01 & - 

\hline

\end{tabular}

<h3>Composant de lecture de la BDD X3</h3>
Notre application a besoin d’accéder en lecture à la base de données de X3. Pour cela, nous allons utiliser une liaison directe avec la BDD Oracle avec un petit programme codé en (Java/PHP/Python ? TBD). Ce programme prendra en entrée :

<ul>
<li> Une requête SQL (Nous utiliserons principalement les vues fournies par Yves)
</li>
<li> Des arguments pour la requête (Dépendant de la requête en question)
</li>
</ul>
Et donnera en sortie : 

<ul>
<li> Le résultat de la requête sous la forme d’un tableau d’objets JSON
</li>
<li> Un statut OK/KO et un message d’erreur s’il y en a une
</li>
</ul>
\begin{tabular}{|p{1.5cm}|p{6cm}|p{6cm}|p{2cm}|}

  \hline

  <b>N°</b> & <b>Tâche</b> & <b>Description</b> & <b>Nécessite</b> 
  \hline

 2-1 & Récupération des données & La récupération des données par le programme doit être fonctionnelle & - 

 \hline

2-2 &	Gestion des erreurs &	Le programme doit correctement renvoyer le statut KO et le message d’erreur s’il en est survenue & - 

  \hline

\end{tabular}

<h3>Composant d’écriture de la BDD X3</h3>
Notre application a besoin d’écrire et de mettre à jour des données dans la BDD d’X3 (Notamment des articles). Pour cela, nous écrivons les données que nous voulons importer dans des fichiers CSV avant d’importer ces fichiers CVS dans le système X3.

Par mesure de sécurité et de simplicité d'utilisation de cet utilitaire, seul des commandes prédéfinies correspondantes aux différents options d'importation vers la BDD que nous offrira Yves. 

\begin{tabular}{|p{1.5cm}|p{6cm}|p{6cm}|p{2cm}|}

  \hline

  <b>N°</b> & <b>Tâche</b> & <b>Description</b> & <b>Nécessite</b> 
  \hline

 3-1 & Écriture des données & L’écriture des données par le programme doit être fonctionnelle & - 

 \hline

3-2 &	Gestion des erreurs &	Le programme doit correctement renvoyer le statut KO et le message d’erreur s’il en est survenue & - 

  \hline

\end{tabular}

<h3>Base de données MySQL</h3>
Afin de stocker les noms des fiches des composants pour permettre de le retrouver facilement, notre projet a besoin d’une base de données. 

Cette base de données sera basée sur MySQL et sera host sur la même machine linux que le serveur web. Cette DBB servant uniquement pour cette fonctionnalité et dans le but de limiter un maximum les données redondantes avec la BDD d’X3, le MCD est très simple :

\begin{tabular}{|p{12cm}|}

  \hline

  <b>Fiche</b> 
  \hline

ref fab VARCHAR(30) PK 

desc VARCHAR(100) 

fiche VARCHAR(30) 

  \hline

\end{tabular} 

Et les tâches à réaliser : 

\begin{tabular}{|p{1.5cm}|p{6cm}|p{6cm}|p{2cm}|}

  \hline

  <b>N°</b> & <b>Tâche</b> & <b>Description</b> & <b>Nécessite</b> 
  \hline

 4-1 & Installation de MySQL-server & Installation de la BDD MySQL sur le serveur linux & 1-1 

 \hline

3-2 &	Création de la BDD &Création de la BDD décrite plus haut & - 

  \hline

\end{tabular}

<h3>Composants généraux serveur WEB</h3>
Un serveur web va être nécessaire pour fournir une interface utilisateur pour chacun des éléments de ce projet. Nous allons donc pour cela :

<ul>
<li> Déployer un serveur web basé sur apache2 et PHP sur la machine linux
</li>
<li> Développer un ensemble de composants JS spécifique aux besoins de ce projet :
</li>
<ul>
<li> Un composant permettant l’affichage et un peu de manipulation de données en tableau exemples : BOM, Résultats API, …
</li>
<li> Un composant permettant de faire un appel direct en JS au composant de lecture de la BDD X3 sur le serveur.
</li>
<li> Un composant permettant de faire un appel direct en JS au composant d’écriture dans la BDD X3 sur le serveur.
</li>
</ul>
</ul>
\begin{tabular}{|p{1.5cm}|p{6cm}|p{6cm}|p{2cm}|}

  \hline

  <b>N°</b> & <b>Tâche</b> & <b>Description</b> & <b>Nécessite</b> 
  \hline

 5-1 & Déploiement du serveur WEB & Déployer le serveur web sur la machine linux & 1-1 

 \hline

5-2 &	Composant JS accès lecture BDD & Réalisation d’un composant JS permettant de faire le lien avec le composant de lecture de la BDD X3 sur le serveur & - 

  \hline

5-3 & Composant JS accès écriture BDD & Réalisation d’un composant JS permettant de faire le lien avec le composant d’écriture de la BDD X3 sur le serveur & - 

  \hline

5-4 &	Composant JS Tableau BDD & Réalisation d’un composant JS permettant l’affichage de données en tableau (BOM, Résultats API, …) & - 

  \hline

5-5 &	Page d’accueil & Création d’une page d’accueil au site pour naviguer à travers ses différentes fonctionnalités & - 

  \hline

\end{tabular}

Pour pouvoir faire le devis d’une BOM, le service achats a besoin des prix de chacun des composants de la BOM. La recherche de ces prix est coûteuse en temps. Or les fournisseurs nous donnes accès a des API permettant de récupérer des informations de prix, MOQ, etc relatives à ces composants automatiquement. Il serait donc intéressant d’aller rechercher ces informations automatiquement afin de réduire la charge de travail du service achats.

Pour cela, il nous semble pertinent de fournir au service achat une page web sur laquelle :

<ul>
<li> L’utilisateur doit entrer ces informations sur la page :
</li>
<ul>
<li> Une BOM sous format CSV composé de : (Ref Fabricant, Quantité par carte, Description).
</li>
<li> Un nombre de cartes à produire
</li>
</ul>
<li> La page doit prendre ces données et :
</li>
<ul>
<li> Comparer les composants de la BOM à la BDD X3 existante pour voir s’ils y figurent
</li>
<li> Aller vérifier grâce aux API des fournisseurs :
</li>
<ul>
<li> Vérifier la présence des composants de la BOM, et si on les trouve, les trouver au meilleur prix, en prenant en compte des infos comme les MOQ.
</li>
<li> Si on ne trouve pas ces composants, vérifier si les fournisseurs on des équivalences. Ces équivalences seront affichées sur la page web et devront être vérifiées à la main via la page web avant d’être validées.
</li>
</ul>
</ul>
<ul>
<li> Vérifier les stocks potentiels des composants de la BOM
</li>
</ul>
<li> Une fois ce traitement valider l’utilisateur peut :
</li>
<ul>
<li> Récupérer ces données sous la forme d’un fichier CSV
</li>
<li> Déclencher une codification automatique de tout les composants découverts grâce aux API des fournisseurs
</li>
</ul>
</ul>
\begin{tabular}{|p{1.5cm}|p{6cm}|p{6cm}|p{2cm}|}

  \hline

  <b>N°</b> & <b>Tâche</b> & <b>Description</b> & <b>Nécessite</b> 
  \hline

 6-1 &Recherche automatique des nouveau composants & Récupération des informations des API à propos d’un composant & -  

 \hline

6-2 & Recherche dans la base X3 des composants connus &Récupération des informations des composants connus par la BDD X3  & 2-1 

  \hline

6-3 & Front Web Page Entrée des informations & Réalisation de la page HTML / CSS d’entrée des informations & - 

  \hline

6-4 &	Front Web Page Résultats & Réalisation de la page HTML / CSS d’affichage des résultats & - 

  \hline

6-5 &Back web & Réalisation de la gestion de la requête AJAX au niveau du serveur (PHP) & - 

  \hline

6-6 & Importation des CSV &L’utilisateur doit pouvoir importer un CSV contenant la BOM simplifiée sur la page WEB  & 4-4 

  \hline

6-7 & Téléchargement des résultats &	L’utilisateur doit pouvoir télécharger les résultats sous forme d’un CSV & 4-4 

  \hline

6-8 & Codification automatique des résultats API &L’utilisateur doit pouvoir déclencher la codification automatique des résultats découverts par API  & 3-1 

  \hline

\end{tabular}

<h3>Organisation des fiches de composants</h3>
Afin de faciliter l’accès aux fiches des composants à tous les utilisateurs, notre projet intègre un page de recherche des fiches composants. A partir de cette page l’utilisateur peut :

<ul>
<li> Rechercher la fiche d’un composant à partir soit de sa référence fabricateur soit de sa référence AODE, soit de sa description.
</li>
<li> Ajouter manuellement une fiche
</li>
<li> Supprimer manuellement une fiche
</li>
</ul>
L’avantage d’incorporer cette fonctionnalité à notre application est, en plus que d’être plus pratique à recherchée qu’un dossier, que des fiches peuvent êtres rajoutés automatiquement au moment des recherches par API.

\begin{tabular}{|p{1.5cm}|p{6cm}|p{6cm}|p{2cm}|}

  \hline

  <b>N°</b> & <b>Tâche</b> & <b>Description</b> & <b>Nécessite</b> 
  \hline

 7-1 & Recherche des fiches à partir de la référence fabriquant ou la description &L’utilisateur peut rechercher une fiche précise à partir de la référence fabricant ou la description du composant & -  

 \hline

7-2 & Recherche des fiches à partir de la référence AODE &L’utilisateur peut rechercher une fiche précise à partir de la référence AODE  & 2-1 

  \hline

7-3 &Ajout manuel d’une fiche &L’utilisateur peut rajouter une fiche à la BDD manuellement & - 

  \hline

7-4 & Suppression manuelle d’une fiche & L’utilisateur peut supprimer une fiche de la BDD manuellement & - 

  \hline

\end{tabular}

<h3>Utilitaire de gestion des Relances</h3>
Afin de simplifier la gestion des relances, notre projet prévois un petit composant en permettant leur gestion. Le but de se composant est de regarder automatiquement dans la BDD d’X3, et d’envoyer un mail de relance aux fournisseurs n’ayant pas envoyés leur commande dans les temps. Pour cela, nous comptons mettre en place un programme python s’exécutant en continu en arrière-plan sur la machine linux. De plus il nous semblerait intéressant de créer avec cet utilitaire une interface web montrant les relances envoyées récemment. 

 

\begin{tabular}{|p{1.5cm}|p{6cm}|p{6cm}|p{2cm}|}

  \hline

  <b>N°</b> & <b>Tâche</b> & <b>Description</b> & <b>Nécessite</b> 
  \hline

 8-1 & Déploiement du composant & Le composant doit tourner en permanence en arrière-plan sur la machine linux & 1-1  

 \hline

8-2 & Envois de mails &Le composant peut envoyer des mails automatiquement via le serveur SMTP d’AODE & - 

  \hline

8-3 & Récupération des commandes en retard & Le composant arrive à récupérer les commandes en retard ainsi qu’une adresse mail de contact liée à cette commande & - 

  \hline

8-4 & Interface WEB & Création d’une interface web liée à ce composant pour permettre aux utilisateurs de tracker les messages envoyés & 8-2 

  \hline

\end{tabular}


<h2 >Gestion des relances</h2>
<h3>Présentation du besoin</h3>
Il faut relancer régulièrement les fournisseurs lorsque le temps de la réponse pour la validation de la commande est trop long.

<h3>Piste suggérée</h3>
En se connectant à la base de données, on peut récupérer les "gap ARC" et envoyer le mail approprié en conséquent via des bibliothèques Python. Le tout encapuslé dans un script, avec un fichier logs pour la tracabilité des mails.

L’envoi se ferait à partir d’un serveur SMTP Outlook basé sur une adresse mail de l’entreprise (adresse mail d'Aline)

<h3>Vérifications</h3>
Le serveur SMTP s’occupe de l’envoi des mails mais normalement, les mails non envoyés sont renvoyés dans la messagerie d’envoi, ce qui permet de vérifier le bon envoi des mails.

<h3>Structure du code</h3>
Sur l'interface principale, le bouton "Mettre à jour" se contente d'appeler un script python qui, lui, va lire la base de données et sauvegarder le contenu dans un fichier au format JSON.

Respectivement, pour :

- les relances ARC : rawARC.json

- les relances retards : rawLate.json

Ensuite, l'interface Web se contente d'afficher le fichier et de pré-cocher les relances sans erreur (c'est à dire avec une adresse mail, principale ou non).

Une fois les postes cochés, l'utilisateur valide avec le bouton "Valider" et la phase de relecture peut commencer. Il suffit juste à l'utilisateur de vérifier si une adresse mail est bien présente.

Enfin, il ne lui reste plus qu'à envoyer les mails en cliquant sur "Envoyer"

Un mail génère une erreur quand l'adresse d'envoi est vide ou bien il y a un espace. 


</body></html>